using Sara.Lib.ConfigurableCommands;
using Sara.Lib.Extensions;
using Sara.Lib.Logging;
using Sara.Lib.Models.Action;
using Sara.Lib.Models.ConfigurableCommand;
using Sara.Lib.Models.Dataset;
using Sara.Lib.Models.Loader;
using Sara.Lib.Models.Log;
using Sara.Lib.Models.Server;
using Dapper;
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Linq;
using System.Text;
using System.IO;
using System.Runtime.InteropServices;
using System.Dynamic;
using Sara.Lib.Models.Configuration;
using Sara.Lib.Models.Notebook;
using Sara.Lib.Cron;

namespace Sara.Lib.Metadata
{
    /// <summary>
    /// Metadata provider via the API database.
    /// </summary>
    public class MSSQLMetadataRepository : AbstractMetadataRepository
    {
        private string ConnectionString { get; set; }

        public MSSQLMetadataRepository(string connectionString)
        {
            this.ConnectionString = connectionString;

            // Map database columns with '_' to C# Objects without '_'.
            Dapper.DefaultTypeMap.MatchNamesWithUnderscores = true;
        }

        #region Initialise

        public override void Initialise()
        {

            var sql = @"

/****** Object:  Sequence [dbo].[SEQ_AUDIT]    Script Date: 31/05/2020 12:53:11 PM ******/
CREATE SEQUENCE [dbo].[SEQ_AUDIT] 
 AS [bigint]
 START WITH 1
 INCREMENT BY 1
 MINVALUE -9223372036854775808
 MAXVALUE 9223372036854775807
 CACHE 
;

/****** Object:  Sequence [dbo].[SEQ_CONFIGURABLE_COMMAND]    Script Date: 31/05/2020 12:53:11 PM ******/
CREATE SEQUENCE [dbo].[SEQ_CONFIGURABLE_COMMAND] 
 AS [bigint]
 START WITH 1
 INCREMENT BY 1
 MINVALUE -9223372036854775808
 MAXVALUE 9223372036854775807
 CACHE 
;

/****** Object:  Sequence [dbo].[SEQ_CONFIGURABLE_COMMAND_SCHEDULE]    Script Date: 31/05/2020 12:53:11 PM ******/
CREATE SEQUENCE [dbo].[SEQ_CONFIGURABLE_COMMAND_SCHEDULE] 
 AS [bigint]
 START WITH 1
 INCREMENT BY 1
 MINVALUE -9223372036854775808
 MAXVALUE 9223372036854775807
 CACHE 
;

/****** Object:  Sequence [dbo].[SEQ_DATASET]    Script Date: 31/05/2020 12:53:11 PM ******/
CREATE SEQUENCE [dbo].[SEQ_DATASET] 
 AS [bigint]
 START WITH 1
 INCREMENT BY 1
 MINVALUE -9223372036854775808
 MAXVALUE 9223372036854775807
 CACHE 
;

/****** Object:  Sequence [dbo].[SEQ_LOG]    Script Date: 31/05/2020 12:53:12 PM ******/
CREATE SEQUENCE [dbo].[SEQ_LOG] 
 AS [bigint]
 START WITH 1
 INCREMENT BY 1
 MINVALUE -9223372036854775808
 MAXVALUE 9223372036854775807
 CACHE 
;

/****** Object:  Sequence [dbo].[SEQ_LOG_ITEM]    Script Date: 31/05/2020 12:53:12 PM ******/
CREATE SEQUENCE [dbo].[SEQ_LOG_ITEM] 
 AS [bigint]
 START WITH 1
 INCREMENT BY 1
 MINVALUE -9223372036854775808
 MAXVALUE 9223372036854775807
 CACHE 
;

/****** Object:  Sequence [dbo].[SEQ_ACTION_QUEUE]    Script Date: 31/05/2020 12:53:12 PM ******/
CREATE SEQUENCE [dbo].[SEQ_ACTION_QUEUE] 
 AS [bigint]
 START WITH 1
 INCREMENT BY 1
 MINVALUE -9223372036854775808
 MAXVALUE 9223372036854775807
 CACHE 
;



GO
-- =============================================
-- Description:	GETS THE LOG. WRITTEN AS
--              TVF RATHER THAN VIEW TO
--              GET ROUND EXEC PLAN ISSUES
--              WHEN DATE RANGE SPECIFIED.
--
--              PASS IN NULL DAYS FOR FULL HISTORY.
--				DAYS HISTORY IS CALCULATED IN 24
--				HOUR BLOCKS INSTEAD OF ASAT
--				MIDNIGHT.
-- =============================================
CREATE FUNCTION [dbo].[TVF_GET_LOG]
(
	@DAYS_HISTORY INT,
	@CLASS VARCHAR(50) = NULL,
	@ITEM_KEY VARCHAR(50) = NULL
)
RETURNS
@RESULTS TABLE 
(
	[LOG_ID] int,
	[EXECUTABLE] varchar(50),
	[CLASS] varchar(50),
	[ITEM_KEY] varchar(250),
	[ITEM_DESCRIPTION] varchar(250),
	[START_DT] datetime2(7),
	[END_DT] datetime2(7),
	[ROWS_AFFECTED] int,
	[SUCCESS_FLAG] bit,
	[CANCELLED_FLAG] bit,
	[LOG_STATUS] varchar(8),
	[DURATION] time(7)
)
AS
BEGIN
	-- Fill the table variable with the rows for your result set

	-- GET HEADER INFO
	DECLARE @LOG_HEADER TABLE (
		LOG_ID INT,
		EXECUTABLE VARCHAR(50),
		CLASS VARCHAR(50),
		ITEM_KEY VARCHAR(250),
		SUCCESS_FLAG BIT,
		CANCELLED_FLAG BIT,
		LOG_ITEM_COUNT INT,
		START_DT DATETIME2(7),
		END_DT DATETIME2(7),
		ROWS_AFFECTED INT
	)

	INSERT INTO @LOG_HEADER
	SELECT
		*,
		(SELECT COUNT(1) START_DT FROM LOG_ITEM LI WHERE (@DAYS_HISTORY IS NULL OR LOG_DT > DATEADD(MINUTE, -(@DAYS_HISTORY * 24 * 60), GETDATE())) AND LI.LOG_ID = LH.LOG_ID) LOG_ITEM_COUNT,
		(SELECT MIN(LOG_DT) START_DT FROM LOG_ITEM LI WHERE LI.LOG_ID = LH.LOG_ID) START_DT,
		(SELECT MAX(LOG_DT) END_DT FROM LOG_ITEM LI WHERE (@DAYS_HISTORY IS NULL OR LOG_DT > DATEADD(MINUTE, -(@DAYS_HISTORY * 24 * 60), GETDATE())) AND LI.LOG_ID = LH.LOG_ID) END_DT,
		(SELECT MAX(ROWS_AFFECTED) FROM LOG_ITEM LI WHERE (@DAYS_HISTORY IS NULL OR LOG_DT > DATEADD(MINUTE, -(@DAYS_HISTORY * 24 * 60), GETDATE())) AND LI.LOG_ID = LH.LOG_ID) ROWS_AFFECTED
	FROM
		LOG_HEADER LH
	WHERE
		((@CLASS IS NOT NULL AND LH.CLASS LIKE @CLASS) OR (@CLASS IS NULL)) AND
		((@ITEM_KEY IS NOT NULL AND LH.ITEM_KEY = @ITEM_KEY) OR (@ITEM_KEY IS NULL))

	DELETE FROM @LOG_HEADER WHERE START_DT IS NULL

	-- GET STATUS
	;WITH cteStatus
	AS
	(
		SELECT
			LOG_ID,
			EXECUTABLE,
			CLASS,
			ITEM_KEY,
			
			-- GET THE DESCRIPTION FOR THE KEY FOR IMPROVED READABILITY
			CASE
				WHEN ISNUMERIC(H.ITEM_KEY) = 1
				THEN (SELECT DESCRIPTION FROM DBO.CONFIGURABLE_COMMAND CC WHERE CAST(CC.CONFIGURABLE_COMMAND_ID AS VARCHAR(8)) = H.ITEM_KEY)
				ELSE
				(SELECT CCC.CLASS_DESC FROM DBO.CONFIGURABLE_COMMAND_CLASS CCC WHERE CLASS_NAME = H.ITEM_KEY)
			END ITEM_DESCRIPTION,

			START_DT,
			END_DT,
			ROWS_AFFECTED,
			SUCCESS_FLAG,
			CANCELLED_FLAG,

			-- STATUS
			CASE SUCCESS_FLAG
			WHEN 1 THEN 'SUCCESS'
			WHEN 0 THEN 'FAILURE'
			ELSE 'PROGRESS'
			END LOG_STATUS
		FROM
			@LOG_HEADER H
		WHERE
			LOG_ITEM_COUNT > 0
	)

	INSERT INTO @RESULTS
	SELECT
		*,
		-- DURATION
		CASE
			WHEN SUCCESS_FLAG IS NOT NULL
			THEN CAST(CAST(END_DT AS DATETIME) - CAST(START_DT AS DATETIME) AS TIME)
			ELSE
				CAST(CAST(GETDATE() AS DATETIME) - CAST(START_DT AS DATETIME) AS TIME)
		END DURATION
	FROM
		cteStatus	
	ORDER BY
		LOG_ID DESC

	RETURN

END
GO

/****** Object:  Table [dbo].[NOTEBOOK]    Script Date: 31/05/2020 12:53:12 PM ******/
CREATE TABLE NOTEBOOK (
	CATEGORY VARCHAR(50) NOT NULL,
	NOTEBOOK VARCHAR(50) NOT NULL,
	SCRIPT VARCHAR(MAX),
 CONSTRAINT [PK_NOTEBOOK] PRIMARY KEY CLUSTERED 
(
	[CATEGORY] ASC, [NOTEBOOK] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[CONFIGURABLE_COMMAND_QUEUE]    Script Date: 31/05/2020 12:53:12 PM ******/
CREATE TABLE [dbo].[CONFIGURABLE_COMMAND_QUEUE](
	[CONFIGURABLE_COMMAND_ID] [int] NOT NULL,
	[NEXT_DT] [datetime2](7) NOT NULL,
	[RUNNING] [bit] NOT NULL,
 CONSTRAINT [PK_CONFIGURABLE_COMMAND_QUEUE] PRIMARY KEY CLUSTERED 
(
	[CONFIGURABLE_COMMAND_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[CONFIGURABLE_COMMAND]    Script Date: 31/05/2020 12:53:12 PM ******/
CREATE TABLE [dbo].[CONFIGURABLE_COMMAND](
	[CONFIGURABLE_COMMAND_ID] [int] NOT NULL,
	[DESCRIPTION] [varchar](255) NOT NULL,
	[CLASS_NAME] [varchar](50) NOT NULL,
	[CREATED_DT] [datetime2](7) NOT NULL,
	[UPDATED_DT] [datetime2](7) NOT NULL,
	[COMMENT] [varchar](1000) NULL,
	[ENABLED_FLAG] [bit] NOT NULL,
 CONSTRAINT [PK_CONFIGURABLE_COMMAND] PRIMARY KEY CLUSTERED 
(
	[CONFIGURABLE_COMMAND_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[CONFIGURABLE_COMMAND_PROPERTY]    Script Date: 31/05/2020 12:53:12 PM ******/
CREATE TABLE [dbo].[CONFIGURABLE_COMMAND_PROPERTY](
	[CONFIGURABLE_COMMAND_ID] [int] NOT NULL,
	[PROPERTY_NAME] [varchar](255) NOT NULL,
	[PROPERTY_VALUE] [varchar](max) NOT NULL,
	[UPDATED_DT] [datetime2](7) NOT NULL,
 CONSTRAINT [PK_CONFIGURABLE_COMMAND_PROPERTY] PRIMARY KEY CLUSTERED 
(
	[CONFIGURABLE_COMMAND_ID] ASC,
	[PROPERTY_NAME] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO

/****** Object:  Table [dbo].[DATASET]    Script Date: 31/05/2020 12:53:12 PM ******/
CREATE TABLE [dbo].[DATASET](
	[DATASET_ID] [int] NOT NULL,
	[CATEGORY] [varchar](50) NOT NULL,
	[DATASET] [varchar](50) NOT NULL,
	[DESCRIPTION] [varchar](1000) NULL,
	[SERVER_NAME] [varchar](50) NOT NULL,
	[SOURCE_NAME] [varchar](255) NOT NULL,
	[DISPLAY_GROUP] [varchar](50) NULL,
	[ACTIVE] [bit] NOT NULL,
	[INTERNAL] [bit] NOT NULL,
	[FORWARD_DATASET_ID] [int] NULL,
	[OWNER] [varchar](255) NULL,
	[WRITEABLE] [bit] NOT NULL,
 CONSTRAINT [PK_DATASET] PRIMARY KEY CLUSTERED 
(
	[DATASET_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [UC_Category_Dataset] UNIQUE NONCLUSTERED 
(
	[CATEGORY] ASC,
	[DATASET] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[SERVER_OBJECT]    Script Date: 31/05/2020 12:53:13 PM ******/
CREATE TABLE [dbo].[SERVER_OBJECT](
	[SERVER_NAME] [varchar](50) NOT NULL,
	[OBJECT_NAME] [sysname] NOT NULL,
	[OBJECT_TYPE] [varchar](50) NOT NULL,
	[ROW_COUNT] [int] NULL,
	[CREATED_DT] [datetime2](7) NOT NULL,
	[MODIFIED_DT] [datetime2](7) NOT NULL,
	[UPDATED_DT] [datetime2](7) NULL,
	[DEFINITION] [varchar](max) NULL,
 CONSTRAINT [PK_SERVER_OBJECT] PRIMARY KEY CLUSTERED 
(
	[SERVER_NAME] ASC,
	[OBJECT_NAME] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO

/****** Object:  View [dbo].[DATASET_SUMMARY]    Script Date: 31/05/2020 12:53:13 PM ******/
CREATE VIEW [dbo].[DATASET_SUMMARY]
AS
	SELECT
		D.*,
		SCO.OBJECT_TYPE,
		SCO.ROW_COUNT,
		SCO.CREATED_DT,
		SCO.MODIFIED_DT,
		SCO.UPDATED_DT,
		SCO.DEFINITION
	FROM
		DATASET D
	LEFT OUTER JOIN
		SERVER_OBJECT SCO
	ON
		D.SERVER_NAME = SCO.SERVER_NAME AND
		D.SOURCE_NAME = SCO.OBJECT_NAME
GO

/****** Object:  Table [dbo].[SERVER_DEPENDENCY]    Script Date: 31/05/2020 12:53:13 PM ******/
CREATE TABLE [dbo].[SERVER_DEPENDENCY](
	[SERVER_NAME] [varchar](50) NOT NULL,
	[PARENT_NAME] [varchar](128) NOT NULL,
	[CHILD_NAME] [varchar](128) NOT NULL,
 CONSTRAINT [PK_SERVER_DEPENDENCY] PRIMARY KEY CLUSTERED 
(
	[SERVER_NAME] ASC,
	[PARENT_NAME] ASC,
	[CHILD_NAME] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  UserDefinedFunction [dbo].[TVF_GET_DEPENDENCIES]    Script Date: 31/05/2020 12:53:13 PM ******/
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE FUNCTION [dbo].[TVF_GET_DEPENDENCIES] 
(	
	@OBJECT_NAME SYSNAME,
	@DIRECTION VARCHAR(4)	-- UP / DOWN
)
RETURNS TABLE 
AS
RETURN 
(
	-- Add the SELECT statement with parameter references here
	-- RETURN DEPENDENCIES
	WITH cteRaw AS
	(
		SELECT
			DEP.SERVER_NAME,
			DEP.PARENT_NAME,
			DEP.CHILD_NAME,
			PAR.OBJECT_TYPE PARENT_OBJECT_TYPE,
			CHI.OBJECT_TYPE CHILD_OBJECT_TYPE
		FROM 
			SERVER_DEPENDENCY DEP
		INNER JOIN
			SERVER_OBJECT PAR
		ON
			DEP.PARENT_NAME = PAR.OBJECT_NAME
		INNER JOIN
			SERVER_OBJECT CHI
		ON
			DEP.CHILD_NAME = CHI.OBJECT_NAME
	)

	, cteDescendants (LEVEL, PARENT_NAME, PARENT_OBJECT_TYPE, CHILD_NAME, CHILD_OBJECT_TYPE) AS
	(
		SELECT
			0 AS LEVEL,
			PARENT_NAME,
			PARENT_OBJECT_TYPE,
			CHILD_NAME,
			CHILD_OBJECT_TYPE
		FROM
			cteRaw R
		WHERE
			R.PARENT_NAME = @OBJECT_NAME
		UNION ALL
		SELECT
			PARENT.LEVEL + 1,
			RAW.PARENT_NAME,
			RAW.PARENT_OBJECT_TYPE,
			RAW.CHILD_NAME,
			RAW.CHILD_OBJECT_TYPE
		FROM
			cteDescendants PARENT
		INNER JOIN
			cteRaw RAW
		ON
			PARENT.CHILD_NAME = RAW.PARENT_NAME
	)

	, cteAncestors (LEVEL, PARENT_NAME, PARENT_OBJECT_TYPE, CHILD_NAME, CHILD_OBJECT_TYPE) AS
	(
		SELECT
			-1 AS LEVEL,
			PARENT_NAME,
			PARENT_OBJECT_TYPE,
			CHILD_NAME,
			CHILD_OBJECT_TYPE
		FROM
			cteRaw R
		WHERE
			R.CHILD_NAME = @OBJECT_NAME
		UNION ALL
		SELECT
			CHILD.LEVEL - 1,
			RAW.PARENT_NAME,
			RAW.PARENT_OBJECT_TYPE,
			RAW.CHILD_NAME,
			RAW.CHILD_OBJECT_TYPE
		FROM
			cteAncestors CHILD
		INNER JOIN
			cteRaw RAW
		ON
			RAW.CHILD_NAME = CHILD.PARENT_NAME
	)
	, cteAll
	AS
	(
		SELECT
			*
		FROM
		(
			SELECT * FROM cteAncestors WHERE @DIRECTION = 'UP'
			UNION
			SELECT * FROM cteDescendants WHERE @DIRECTION = 'DOWN'
		) A
	)

	-- Gets all distinct objects and assigns a unique id to each
	, cteGetIds
	AS
	(
		SELECT
			*,
			ROW_NUMBER() OVER (ORDER BY OBJECT_NAME) ID
		FROM
		(
			SELECT DISTINCT
				CHILD_NAME OBJECT_NAME,
				CHILD_OBJECT_TYPE OBJECT_TYPE
			FROM
				cteAll
			UNION
			SELECT DISTINCT
				PARENT_NAME OBJECT_NAME,
				PARENT_OBJECT_TYPE OBJECT_TYPE
			FROM
				cteAll
		) A
	)
	, cteFinal
	AS
	(
		SELECT DISTINCT
			C.ID,	-- THE ID
			COALESCE(P.ID, 0) PARENT_ID,	-- THE PARENT ID
			C.OBJECT_NAME,
			C.OBJECT_TYPE
		FROM
			cteAll F
		INNER JOIN
			cteGetIds P
		ON
			F.PARENT_NAME = P.OBJECT_NAME
		-- ALWAYS HAVE A CHILD
		RIGHT OUTER JOIN
			cteGetIds C
		ON
			F.CHILD_NAME = C.OBJECT_NAME
	)
	, cteHierarchicalExplosion
	AS
	(
		-- SELECT ORIGINAL ITEM REQUESTED
		SELECT DISTINCT CAST(ROOT.ID AS VARCHAR(1000)) SURROGATE_KEY, CAST('' AS VARCHAR(1000)) RELATION_SURROGATE_KEY, *, CAST('ROOT' AS VARCHAR(255)) NODE_TYPE FROM cteFinal ROOT WHERE OBJECT_NAME = @OBJECT_NAME
		UNION ALL
		-- CHILDREN / DOWN
		SELECT CAST(P.SURROGATE_KEY + '.' + CAST(C.ID AS VARCHAR(255)) AS VARCHAR(1000)), P.SURROGATE_KEY RELATION_SURROGATE_KEY, C.ID, C.PARENT_ID, C.OBJECT_NAME, C.OBJECT_TYPE, CAST('CHILD' AS VARCHAR(255)) FROM cteFinal C INNER JOIN cteHierarchicalExplosion P ON C.PARENT_ID = P.ID AND @DIRECTION = 'DOWN'
		UNION ALL
		-- PARENTS / UP
		SELECT CAST(C.SURROGATE_KEY + '.' + CAST(P.ID AS VARCHAR(255)) AS VARCHAR(1000)), C.SURROGATE_KEY RELATION_SURROGATE_KEY, P.ID, P.PARENT_ID, P.OBJECT_NAME, P.OBJECT_TYPE, CAST('PARENT' AS VARCHAR(255)) FROM cteFinal P INNER JOIN cteHierarchicalExplosion C ON C.PARENT_ID = P.ID AND @DIRECTION = 'UP'
	)

	, cteFinal3
	AS
	(
		SELECT
			DISTINCT
				SURROGATE_KEY,
				RELATION_SURROGATE_KEY,
				EX.OBJECT_NAME,
				EX.OBJECT_TYPE,
				NODE_TYPE,
				IDS.UPDATED_DT
				LAST_UPDATED_DT,
				IDS.ROW_COUNT
		FROM
			cteHierarchicalExplosion EX
		-- GET LAST UPDATED DATE/TIME
		LEFT OUTER JOIN
			SERVER_OBJECT IDS
		ON
			EX.OBJECT_NAME = IDS.OBJECT_NAME
	)

	SELECT
		*
	FROM
		cteFinal3
	
	UNION ALL
	
	-- IF NO DEPENDENCY INFORMATION FOUND, JUST RETURN THE OBJECT ITSELF
	SELECT
		'1',
		'', 
		OBJECT_NAME,
		OBJECT_TYPE,
		'ROOT',
		UPDATED_DT,
		ROW_COUNT
	FROM
		SERVER_OBJECT
	WHERE
		OBJECT_NAME = @OBJECT_NAME AND
		(SELECT COUNT(1) FROM cteFinal3) = 0
)
GO

/****** Object:  Table [dbo].[AUDIT_ITEM]    Script Date: 31/05/2020 12:53:13 PM ******/
CREATE TABLE [dbo].[AUDIT_ITEM](
	[AUDIT_ID] [int] NOT NULL,
	[ARGUMENT_NAME] [varchar](50) NOT NULL,
	[ARGUMENT_VALUE] [varchar](2000) NOT NULL,
 CONSTRAINT [PK_AUDIT_ITEM] PRIMARY KEY CLUSTERED 
(
	[AUDIT_ID] ASC,
	[ARGUMENT_NAME] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[AUDIT_HEADER]    Script Date: 31/05/2020 12:53:13 PM ******/
CREATE TABLE [dbo].[AUDIT_HEADER](
	[AUDIT_ID] [int] NOT NULL,
	[AUDIT_DT] [datetime2](7) NULL,
	[USER_NAME] [nvarchar](128) NULL,
	[CONTROLLER] [nvarchar](128) NULL,
	[ACTION] [nvarchar](128) NULL,
	[DURATION] [time](7) NULL,
 CONSTRAINT [PK_AUDIT_HEADER] PRIMARY KEY CLUSTERED 
(
	[AUDIT_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  View [dbo].[DATASET_AUDIT]    Script Date: 31/05/2020 12:53:13 PM ******/
-------------------------------
-- AUDIT LOG
--
-- ALL AUDIT ENTRIES RELATING
-- TO DATASETS.
-------------------------------
CREATE VIEW [dbo].[DATASET_AUDIT]
AS
	SELECT
		H.*,
		DATEDIFF(SECOND, '0:00:00', DURATION) DURATION_SECS,
		ITEM_CAT.ARGUMENT_VALUE AS CATEGORY,
		ITEM_DATASET.ARGUMENT_VALUE AS DATASET
	FROM
		AUDIT_HEADER H
	LEFT OUTER JOIN
		AUDIT_ITEM ITEM_CAT
	ON
		ITEM_CAT.AUDIT_ID = H.AUDIT_ID AND
		ITEM_CAT.ARGUMENT_NAME = 'category'
	LEFT OUTER JOIN
		AUDIT_ITEM ITEM_DATASET
	ON
		ITEM_DATASET.AUDIT_ID = H.AUDIT_ID AND
		ITEM_DATASET.ARGUMENT_NAME = 'dataset'
	WHERE
		ITEM_CAT.AUDIT_ID IS NOT NULL AND
		ITEM_DATASET.AUDIT_ID IS NOT NULL
GO

/****** Object:  View [dbo].[BASE_OBJECT]    Script Date: 31/05/2020 12:53:13 PM ******/
---------------------------------------
-- GETS THE BASE OBJECT FOR A PARENT
-- OBJECT.
-- FOR SYNONYMS, BASE OBJECT IS THE
-- SYNONYM BASE OBJECT. FOR OTHER
-- OBJECTS, BASE OBJECT = PARENT OBJECT
---------------------------------------
CREATE VIEW [dbo].[BASE_OBJECT]
AS
	SELECT
		OBJ.SERVER_NAME,
		PARENT_NAME,
		CASE WHEN OBJECT_TYPE = 'SYNONYM' THEN DEP.CHILD_NAME ELSE PARENT_NAME END CHILD_NAME
	FROM
		SERVER_OBJECT OBJ
	LEFT OUTER JOIN
		(SELECT *, ROW_NUMBER() OVER (PARTITION BY SERVER_NAME, PARENT_NAME ORDER BY CHILD_NAME) SEQ FROM SERVER_DEPENDENCY) DEP
	ON
		DEP.SEQ = 1 AND
		OBJ.OBJECT_NAME = DEP.PARENT_NAME
	WHERE
		PARENT_NAME IS NOT NULL
GO

/****** Object:  Table [dbo].[LOADER]    Script Date: 31/05/2020 12:53:13 PM ******/
CREATE TABLE [dbo].[LOADER](
	[CONFIGURABLE_COMMAND_ID] [int] NOT NULL,
	[TARGET_BEHAVIOUR] [varchar](20) NOT NULL,
	[BEFORE_ROW_PROCESSING_SQL] [varchar](1000) NULL,
	[ROW_PROCESSING_BEHAVIOUR] [varchar](20) NOT NULL,
	[AFTER_ROW_PROCESSING_SQL] [varchar](1000) NULL,
	[SERVER_NAME] [varchar](50) NOT NULL,
	[TARGET_NAME] [varchar](250) NOT NULL,
 CONSTRAINT [PK_LOADER] PRIMARY KEY CLUSTERED 
(
	[CONFIGURABLE_COMMAND_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  UserDefinedFunction [dbo].[GET_LOADER_HISTORY_FOR_OBJECT]    Script Date: 31/05/2020 12:53:14 PM ******/
-- =============================================
-- Description:	GETS LOADER INFORMATION FOR A
--              BASE TABLE.
-- =============================================
CREATE FUNCTION [dbo].[GET_LOADER_HISTORY_FOR_OBJECT]
(	
	-- Add the parameters for the function here
	@OBJECT_NAME SYSNAME,
	@DAYS INT
)
RETURNS TABLE 
AS
RETURN 
(
	WITH cteLoaders
	AS
	(
		SELECT
			CC.[CONFIGURABLE_COMMAND_ID]
		FROM
			CONFIGURABLE_COMMAND CC
		INNER JOIN
			LOADER L
		ON
			CC.CONFIGURABLE_COMMAND_ID = L.CONFIGURABLE_COMMAND_ID
		WHERE
			L.TARGET_NAME = @OBJECT_NAME
	)

    SELECT
		*
	FROM
		TVF_GET_LOG(@DAYS, NULL, NULL)
	WHERE
        ISNUMERIC(ITEM_KEY) = 1 AND
		ITEM_KEY IN (
			SELECT CONFIGURABLE_COMMAND_ID FROM cteLoaders
		)
)
GO

/****** Object:  View [dbo].[STALE_MATERIALISED_VIEWS]    Script Date: 31/05/2020 12:53:14 PM ******/
CREATE VIEW [dbo].[STALE_MATERIALISED_VIEWS]
AS
	WITH cteObjects
	AS
	(
		SELECT
			C.OBJECT_NAME SOURCE_NAME,
			OBJECT_TYPE,
			UPDATED_DT
		FROM
			SERVER_OBJECT C
	)

		SELECT
			-- THE BASE / CHILD TABLE
			T1.SOURCE_NAME BASE_SOURCE_NAME,
			T1.UPDATED_DT BASE_UPDATED_DT,

			-- THE MATERIALISED VIEW
			T2.SOURCE_NAME MATERIALISED_VIEW_SOURCE_NAME,
			T2.UPDATED_DT MATERIALISED_VIEW_UPDATED_DT
		FROM
		(
			SELECT * FROM cteObjects WHERE OBJECT_TYPE IN ('BASE TABLE','MATERIALISED VIEW')
		) T1
		CROSS APPLY
			DBO.TVF_GET_DEPENDENCIES(T1.SOURCE_NAME, 'UP') DEP
		INNER JOIN
		(
			SELECT * FROM cteObjects WHERE OBJECT_TYPE = 'MATERIALISED VIEW'
		) T2
		ON
			DEP.OBJECT_NAME = T2.SOURCE_NAME
		WHERE
			DEP.OBJECT_TYPE = 'MATERIALISED VIEW' AND
			NOT (T1.SOURCE_NAME = T2.SOURCE_NAME) AND
			COALESCE(T2.UPDATED_DT, '31-DEC-9999') > T1.UPDATED_DT
GO

/****** Object:  Table [dbo].[ACTION_QUEUE]    Script Date: 31/05/2020 12:53:14 PM ******/
CREATE TABLE [dbo].[ACTION_QUEUE](
	[ACTION_QUEUE_ID] [int] NOT NULL,
	[DUE_DT] [datetime] NOT NULL,
	[BEGIN_DT] [datetime] NULL,
	[END_DT] [datetime] NULL,
	[ACTION] [varchar](50) NOT NULL,
	[PARAMETERS] [varchar](250) NULL,
	[STATUS] [varchar](50) NOT NULL,
	[EXCEPTION] [varchar](255) NULL
 CONSTRAINT [PK_ACTION_QUEUE] PRIMARY KEY CLUSTERED 
(
	[ACTION_QUEUE_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[CONFIGURABLE_COMMAND_CLASS]    Script Date: 31/05/2020 12:53:14 PM ******/
CREATE TABLE [dbo].[CONFIGURABLE_COMMAND_CLASS](
	[CLASS_NAME] [varchar](50) NOT NULL,
	[CLASS_TYPE] [varchar](50) NOT NULL,
	[CLASS_DESC] [varchar](250) NOT NULL,
	[TYPE_NAME] [varchar](250) NOT NULL
 CONSTRAINT [PK_CONFIGURABLE_COMMAND_CLASS] PRIMARY KEY CLUSTERED 
(
	[CLASS_NAME] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  View [dbo].[MATERIALISED_VIEWS]    Script Date: 31/05/2020 12:53:12 PM ******/
-------------------------------------
-- CREATE NEW MATERIALISED_VIEWS VIEW
--
-- THIS IS USED BY THE SERVER SCAN
-- ACTION.
-------------------------------------
CREATE VIEW [dbo].[MATERIALISED_VIEWS]
AS
	SELECT
		PROP_SRC.PROPERTY_VALUE SOURCE_VIEW_NAME,
		PROP_DEST.PROPERTY_VALUE TARGET_TABLE_NAME
	FROM
		CONFIGURABLE_COMMAND CMD
	INNER JOIN
		CONFIGURABLE_COMMAND_CLASS CCC
	ON
		CMD.CLASS_NAME = CCC.CLASS_NAME
	INNER JOIN
		CONFIGURABLE_COMMAND_PROPERTY PROP_SRC
	ON
		CMD.CONFIGURABLE_COMMAND_ID = PROP_SRC.CONFIGURABLE_COMMAND_ID AND
		CMD.CLASS_NAME = 'MaterialiseView' AND CCC.CLASS_TYPE = 'Action' AND
		PROP_SRC.PROPERTY_NAME = 'SOURCE_VIEW_NAME'
	INNER JOIN
		CONFIGURABLE_COMMAND_PROPERTY PROP_DEST
	ON
		CMD.CONFIGURABLE_COMMAND_ID = PROP_DEST.CONFIGURABLE_COMMAND_ID AND
		CMD.CLASS_NAME = 'MaterialiseView' AND CCC.CLASS_TYPE = 'Action' AND
		PROP_DEST.PROPERTY_NAME = 'TARGET_TABLE_NAME'
GO

/****** Object:  Table [dbo].[CONFIGURABLE_COMMAND_PRECONDITION]    Script Date: 31/05/2020 12:53:14 PM ******/
CREATE TABLE [dbo].[CONFIGURABLE_COMMAND_PRECONDITION](
	[CONFIGURABLE_COMMAND_ID] [int] NOT NULL,
	[PRECONDITION_ID] [int] NOT NULL,
	[SUCCESS_FLAG] [bit] NULL,
	[AUTO_SCHEDULE_FLAG] [bit] NOT NULL,
 CONSTRAINT [PK_CONFIGURABLE_COMMAND_PRECONDITION] PRIMARY KEY CLUSTERED 
(
	[CONFIGURABLE_COMMAND_ID] ASC,
	[PRECONDITION_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[CONFIGURABLE_COMMAND_SCHEDULE]    Script Date: 31/05/2020 12:53:14 PM ******/
CREATE TABLE [dbo].[CONFIGURABLE_COMMAND_SCHEDULE](
	[CONFIGURABLE_COMMAND_SCHEDULE_ID] [int] NOT NULL,
	[CONFIGURABLE_COMMAND_ID] [int] NOT NULL,
	[CRON] [varchar](50) NOT NULL,
	[ONE_TIME] [bit] NOT NULL,
	[CREATED_DT] [datetime2](7) NOT NULL,
	[UPDATED_DT] [datetime2](7) NOT NULL,
	[ENABLED_FLAG] [bit] NOT NULL,
 CONSTRAINT [PK_CONFIGURABLE_COMMAND_SCHEDULE] PRIMARY KEY CLUSTERED 
(
	[CONFIGURABLE_COMMAND_SCHEDULE_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[CONFIGURATION]    Script Date: 31/05/2020 12:53:14 PM ******/
CREATE TABLE [dbo].[CONFIGURATION](
	[CONFIGURATION_NAME] [varchar](250) NOT NULL,
	[CONFIGURATION_DESC] [varchar](1000) NOT NULL,
	[CONFIGURATION_VALUE] [varchar](250) NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[CONFIGURATION_NAME] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[LOADER_COLUMN]    Script Date: 31/05/2020 12:53:15 PM ******/
CREATE TABLE [dbo].[LOADER_COLUMN](
	[CONFIGURABLE_COMMAND_ID] [int] NOT NULL,
	[COLUMN_NAME] [varchar](128) NOT NULL,
	[SEQ] [int] NOT NULL,
	[PRIMARY_KEY] [bit] NOT NULL,
	[DATA_TYPE] [varchar](20) NOT NULL,
	[DATA_LENGTH] [int] NOT NULL,
	[SELECTED] [bit] NOT NULL,
	[UPDATED_DT] [datetime2](7) NOT NULL,
 CONSTRAINT [PK_LOADER_COLUMN] PRIMARY KEY CLUSTERED 
(
	[CONFIGURABLE_COMMAND_ID] ASC,
	[COLUMN_NAME] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[LOADER_PROBE_QUEUE]    Script Date: 31/05/2020 12:53:15 PM ******/
CREATE TABLE [dbo].[LOADER_PROBE_QUEUE](
	[CONFIGURABLE_COMMAND_ID] [int] NOT NULL,
 CONSTRAINT [PK_LOADER_PROBE_QUEUE] PRIMARY KEY CLUSTERED 
(
	[CONFIGURABLE_COMMAND_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[LOG_HEADER]    Script Date: 31/05/2020 12:53:15 PM ******/
CREATE TABLE [dbo].[LOG_HEADER](
	[LOG_ID] [int] NOT NULL,
	[EXECUTABLE] [varchar](50) NOT NULL,
	[CLASS] [varchar](50) NOT NULL,
	[ITEM_KEY] [varchar](250) NULL,
	[SUCCESS_FLAG] [bit] NULL,
	[CANCELLED_FLAG] [bit] NULL,
 CONSTRAINT [PK_LOG_HEADER] PRIMARY KEY CLUSTERED 
(
	[LOG_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[LOG_ITEM]    Script Date: 31/05/2020 12:53:15 PM ******/
CREATE TABLE [dbo].[LOG_ITEM](
	[LOG_ITEM_ID] [int] NOT NULL,
	[LOG_ID] [int] NOT NULL,
	[LOG_DT] [datetime2](7) NOT NULL,
	[EXECUTABLE] [varchar](50) NOT NULL,
	[CLASS] [varchar](50) NOT NULL,
	[METHOD] [varchar](50) NOT NULL,
	[LOG_TYPE] [varchar](50) NOT NULL,
	[MESSAGE] [varchar](1000) NOT NULL,
	[ROWS_AFFECTED] [int] NULL,
 CONSTRAINT [PK_LOG_ITEM] PRIMARY KEY CLUSTERED 
(
	[LOG_ITEM_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[SERVER]    Script Date: 31/05/2020 12:53:15 PM ******/
CREATE TABLE [dbo].[SERVER](
	[SERVER_NAME] [varchar](50) NOT NULL,
	[TYPE_NAME] [varchar](50) NOT NULL,
	[CONNECTION_STRING] [varchar](1000) NOT NULL,
 CONSTRAINT [PK_SERVER] PRIMARY KEY CLUSTERED 
(
	[SERVER_NAME] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[SERVER_COLUMN]    Script Date: 31/05/2020 12:53:16 PM ******/
CREATE TABLE [dbo].[SERVER_COLUMN](
	[SERVER_NAME] [varchar](50) NOT NULL,
	[OBJECT_NAME] [varchar](128) NOT NULL,
	[COLUMN_NAME] [varchar](128) NOT NULL,
	[ORDER] [int] NOT NULL,
	[DATA_TYPE] [varchar](50) NOT NULL,
	[DATA_LENGTH] [int] NULL,
	[PRECISION] [tinyint] NULL,
	[SCALE] [tinyint] NULL,
	[PRIMARY_KEY] [bit] NULL,
	[READ_ONLY] [bit] NOT NULL,
	[PUBLIC] [bit] NOT NULL,
 CONSTRAINT [PK_SERVER_COLUMN] PRIMARY KEY CLUSTERED 
(
	[SERVER_NAME] ASC,
	[OBJECT_NAME] ASC,
	[COLUMN_NAME] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Table [dbo].[SERVER_PARAMETER]    Script Date: 31/05/2020 12:53:16 PM ******/
CREATE TABLE [dbo].[SERVER_PARAMETER](
	[SERVER_NAME] [varchar](50) NOT NULL,
	[OBJECT_NAME] [nvarchar](128) NOT NULL,
	[PARAMETER_ID] [int] NOT NULL,
	[PARAMETER_NAME] [nvarchar](128) NOT NULL,
	[DATA_TYPE] [nvarchar](50) NOT NULL,
	[MAXIMUM_LENGTH] [int] NOT NULL,
	[IS_NULLABLE] [bit] NOT NULL,
 CONSTRAINT [PK_SERVER_PARAMETER] PRIMARY KEY CLUSTERED 
(
	[SERVER_NAME] ASC,
	[OBJECT_NAME] ASC,
	[PARAMETER_NAME] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

/****** Object:  Index [IDX_AUDIT_HEADER_AUDIT_DT]    Script Date: 31/05/2020 12:53:16 PM ******/
CREATE NONCLUSTERED INDEX [IDX_AUDIT_HEADER_AUDIT_DT] ON [dbo].[AUDIT_HEADER]
(
	[AUDIT_DT] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO

/****** Object:  Index [IDX_DATASET_CATEGORY_DATASET]    Script Date: 31/05/2020 12:53:16 PM ******/
CREATE UNIQUE NONCLUSTERED INDEX [IDX_DATASET_CATEGORY_DATASET] ON [dbo].[DATASET]
(
	[CATEGORY] ASC,
	[DATASET] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO

ALTER TABLE [dbo].[CONFIGURABLE_COMMAND] ADD  DEFAULT (getdate()) FOR [CREATED_DT]
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND] ADD  DEFAULT (getdate()) FOR [UPDATED_DT]
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND] ADD  DEFAULT ((0)) FOR [ENABLED_FLAG]
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND_PROPERTY] ADD  DEFAULT (getdate()) FOR [UPDATED_DT]
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND_QUEUE] ADD  DEFAULT ((0)) FOR [RUNNING]
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND_SCHEDULE] ADD  DEFAULT (getdate()) FOR [CREATED_DT]
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND_SCHEDULE] ADD  DEFAULT (getdate()) FOR [UPDATED_DT]
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND_SCHEDULE] ADD  DEFAULT ((1)) FOR [ENABLED_FLAG]
GO
ALTER TABLE [dbo].[DATASET] ADD  DEFAULT ((0)) FOR [WRITEABLE]
GO
ALTER TABLE [dbo].[LOADER] ADD  DEFAULT (' ') FOR [SERVER_NAME]
GO
ALTER TABLE [dbo].[LOADER] ADD  DEFAULT (' ') FOR [TARGET_NAME]
GO
ALTER TABLE [dbo].[LOADER_COLUMN] ADD  DEFAULT (getdate()) FOR [UPDATED_DT]
GO
ALTER TABLE [dbo].[LOG_HEADER] ADD  DEFAULT ((0)) FOR [CANCELLED_FLAG]
GO
ALTER TABLE [dbo].[LOG_ITEM] ADD  DEFAULT (getdate()) FOR [LOG_DT]
GO
ALTER TABLE [dbo].[AUDIT_ITEM]  WITH CHECK ADD  CONSTRAINT [FK_AUDIT_ITEM_AUDIT_HEADER] FOREIGN KEY([AUDIT_ID])
REFERENCES [dbo].[AUDIT_HEADER] ([AUDIT_ID])
GO
ALTER TABLE [dbo].[AUDIT_ITEM] CHECK CONSTRAINT [FK_AUDIT_ITEM_AUDIT_HEADER]
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND_PROPERTY]  WITH CHECK ADD  CONSTRAINT [FK_CONFIGURABLE_COMMAND_PROPERTY_CONFIGURABLE_COMMAND] FOREIGN KEY([CONFIGURABLE_COMMAND_ID])
REFERENCES [dbo].[CONFIGURABLE_COMMAND] ([CONFIGURABLE_COMMAND_ID])
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND_PROPERTY] CHECK CONSTRAINT [FK_CONFIGURABLE_COMMAND_PROPERTY_CONFIGURABLE_COMMAND]
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND_PRECONDITION]  WITH CHECK ADD  CONSTRAINT [FK_CONFIGURABLE_COMMAND_PRECONDITION_CONFIGURABLE_COMMAND] FOREIGN KEY([CONFIGURABLE_COMMAND_ID])
REFERENCES [dbo].[CONFIGURABLE_COMMAND] ([CONFIGURABLE_COMMAND_ID])
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND_PRECONDITION] CHECK CONSTRAINT [FK_CONFIGURABLE_COMMAND_PRECONDITION_CONFIGURABLE_COMMAND]
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND_QUEUE]  WITH CHECK ADD  CONSTRAINT [FK_CONFIGURABLE_COMMAND_QUEUE_CONFIGURABLE_COMMAND] FOREIGN KEY([CONFIGURABLE_COMMAND_ID])
REFERENCES [dbo].[CONFIGURABLE_COMMAND] ([CONFIGURABLE_COMMAND_ID])
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND_QUEUE] CHECK CONSTRAINT [FK_CONFIGURABLE_COMMAND_QUEUE_CONFIGURABLE_COMMAND]
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND_SCHEDULE]  WITH CHECK ADD  CONSTRAINT [FK_CONFIGURABLE_COMMAND_SCHEDULE_CONFIGURABLE_COMMAND] FOREIGN KEY([CONFIGURABLE_COMMAND_ID])
REFERENCES [dbo].[CONFIGURABLE_COMMAND] ([CONFIGURABLE_COMMAND_ID])
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND_SCHEDULE] CHECK CONSTRAINT [FK_CONFIGURABLE_COMMAND_SCHEDULE_CONFIGURABLE_COMMAND]
GO
ALTER TABLE [dbo].[LOADER]  WITH CHECK ADD  CONSTRAINT [FK_LOADER_CONFIGURABLE_COMMAND] FOREIGN KEY([CONFIGURABLE_COMMAND_ID])
REFERENCES [dbo].[CONFIGURABLE_COMMAND] ([CONFIGURABLE_COMMAND_ID])
GO
ALTER TABLE [dbo].[LOADER] CHECK CONSTRAINT [FK_LOADER_CONFIGURABLE_COMMAND]
GO
ALTER TABLE [dbo].[LOADER_COLUMN]  WITH CHECK ADD  CONSTRAINT [FK_LOADER_COLUMN_LOADER] FOREIGN KEY([CONFIGURABLE_COMMAND_ID])
REFERENCES [dbo].[LOADER] ([CONFIGURABLE_COMMAND_ID])
GO
ALTER TABLE [dbo].[LOADER_COLUMN] CHECK CONSTRAINT [FK_LOADER_COLUMN_LOADER]
GO
ALTER TABLE [dbo].[LOADER_PROBE_QUEUE]  WITH CHECK ADD  CONSTRAINT [FK_LOADER_QUEUE_CONFIGURABLE_COMMAND] FOREIGN KEY([CONFIGURABLE_COMMAND_ID])
REFERENCES [dbo].[CONFIGURABLE_COMMAND] ([CONFIGURABLE_COMMAND_ID])
GO
ALTER TABLE [dbo].[LOADER_PROBE_QUEUE] CHECK CONSTRAINT [FK_LOADER_QUEUE_CONFIGURABLE_COMMAND]
GO
ALTER TABLE [dbo].[LOG_ITEM]  WITH CHECK ADD  CONSTRAINT [FK_LOG_ITEM_LOG_HEADER] FOREIGN KEY([LOG_ID])
REFERENCES [dbo].[LOG_HEADER] ([LOG_ID])
GO
ALTER TABLE [dbo].[LOG_ITEM] CHECK CONSTRAINT [FK_LOG_ITEM_LOG_HEADER]
GO
ALTER TABLE [dbo].[SERVER_COLUMN]  WITH NOCHECK ADD  CONSTRAINT [FK_SERVER_COLUMN_SERVER] FOREIGN KEY([SERVER_NAME])
REFERENCES [dbo].[SERVER] ([SERVER_NAME])
GO
ALTER TABLE [dbo].[SERVER_COLUMN] CHECK CONSTRAINT [FK_SERVER_COLUMN_SERVER]
GO
ALTER TABLE [dbo].[SERVER_DEPENDENCY]  WITH NOCHECK ADD  CONSTRAINT [FK_SERVER_DEPENDENCY_SERVER] FOREIGN KEY([SERVER_NAME])
REFERENCES [dbo].[SERVER] ([SERVER_NAME])
GO
ALTER TABLE [dbo].[SERVER_DEPENDENCY] CHECK CONSTRAINT [FK_SERVER_DEPENDENCY_SERVER]
GO
ALTER TABLE [dbo].[SERVER_OBJECT]  WITH NOCHECK ADD  CONSTRAINT [FK_SERVER_OBJECT_SERVER] FOREIGN KEY([SERVER_NAME])
REFERENCES [dbo].[SERVER] ([SERVER_NAME])
GO
ALTER TABLE [dbo].[SERVER_OBJECT] CHECK CONSTRAINT [FK_SERVER_OBJECT_SERVER]
GO
ALTER TABLE [dbo].[SERVER_PARAMETER]  WITH NOCHECK ADD  CONSTRAINT [FK_SERVER_PARAMETER_SERVER] FOREIGN KEY([SERVER_NAME])
REFERENCES [dbo].[SERVER] ([SERVER_NAME])
GO
ALTER TABLE [dbo].[SERVER_PARAMETER] CHECK CONSTRAINT [FK_SERVER_PARAMETER_SERVER]
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND]  WITH NOCHECK ADD  CONSTRAINT [FK_CONFIGURABLE_COMMAND_CONFIGURABLE_COMMAND_CLASS] FOREIGN KEY([CLASS_NAME])
REFERENCES [dbo].[CONFIGURABLE_COMMAND_CLASS] ([CLASS_NAME])
GO
ALTER TABLE [dbo].[CONFIGURABLE_COMMAND] CHECK CONSTRAINT [FK_CONFIGURABLE_COMMAND_CONFIGURABLE_COMMAND_CLASS]
GO

/****** Object:  StoredProcedure [dbo].[SP_HOUSEKEEPING]    Script Date: 31/05/2020 12:53:16 PM ******/
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[SP_HOUSEKEEPING]
	-- Add the parameters for the stored procedure here
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

END
GO

ALTER DATABASE [SARA] SET  READ_WRITE 
GO
";

            using (var connection = new SqlConnection(ConnectionString))
            {
                connection.Open();
                connection.ChangeDatabase("Sara");

                // Only run this script if no schema present.
                // Check for presence of the 'DATASET' table.
                var schemaExists = connection.ExecuteScalar<string>(@"
IF OBJECT_ID (N'DATASET', N'U') IS NOT NULL
	SELECT 'YES'
ELSE
	SELECT 'NO'
");
                if (schemaExists == "NO")
                {
                    using (var command = connection.CreateCommand())
                    {
                        foreach (var item in sql.Split(new string[] { $"{Environment.NewLine}GO{Environment.NewLine}" }, StringSplitOptions.None)) //// $"{Environment.NewLine}GO{Environment.NewLine}"
                        {
                            if (!string.IsNullOrEmpty(item))
                            {
                                command.CommandText = item;
                                command.ExecuteNonQuery();
                            }
                        }
                    }
                }
            }
        }

        #endregion

        #region Environment

        public override SaraEnvironment GetEnvironment()
        {
            /*
            using (var db = new SqlConnection(ConnectionString))
            {
                var servername = db.ExecuteScalar<string>("SELECT @@SERVERNAME");
                var environment = Enum.Parse<SaraEnvironment>(servername == "bvbisqlprd" ? "Production" : "Development");
                return environment;
            }
            */
            return SaraEnvironment.Production;
        }

        #endregion

        #region Servers

        public override IEnumerable<ServerInfo> GetServers()
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var servers = db.Query<ServerInfo>("SELECT * FROM SERVER");
                return servers;
            }
        }

        public override void AddServer(ServerInfo server)
        {
            using (var connection = new SqlConnection(ConnectionString))
            {
                connection.Execute("INSERT INTO SERVER (SERVER_NAME, TYPE_NAME, CONNECTION_STRING) SELECT @SERVER_NAME, @TYPE_NAME, @CONNECTION_STRING", new
                {
                    SERVER_NAME = server.ServerName,
                    TYPE_NAME = server.TypeName,
                    CONNECTION_STRING = server.ConnectionString ?? ""
                });
            }
        }

        public override void DeleteServer(string serverName)
        {
            using (var connection = new SqlConnection(ConnectionString))
            {
                connection.Execute("DELETE FROM SERVER WHERE SERVER_NAME = @SERVER_NAME", new
                {
                    SERVER_NAME = serverName
                });
            }
        }

        #endregion

        #region Configuration

        public override IEnumerable<ConfigurationInfo> GetConfiguration()
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                return db.Query<ConfigurationInfo>("SELECT * FROM CONFIGURATION");
            }
        }

        public override void SetConfiguration(ConfigurationInfo item)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var sql = @"
DELETE FROM CONFIGURATION WHERE CONFIGURATION_NAME = @CONFIGURATION_NAME;
INSERT INTO CONFIGURATION (CONFIGURATION_NAME, CONFIGURATION_DESC, CONFIGURATION_VALUE)
SELECT @CONFIGURATION_NAME, @CONFIGURATION_DESC, @CONFIGURATION_VALUE;";

                db.Execute(sql, new
                {
                    CONFIGURATION_NAME = item.ConfigurationName,
                    CONFIGURATION_DESC = item.ConfigurationDesc,
                    CONFIGURATION_VALUE = item.ConfigurationValue
                });
            }
        }

        public override void UnsetConfiguration(string configurationName)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var sql = @"DELETE FROM CONFIGURATION WHERE CONFIGURATION_NAME = @CONFIGURATION_NAME";

                db.Execute(sql, new
                {
                    CONFIGURATION_NAME = configurationName
                });
            }
        }

        #endregion

        #region Configurable Commands

        public override IEnumerable<ConfigurableCommandInfo> GetConfigurableCommands()
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var cc = db.Query<ConfigurableCommandInfo>("SELECT * FROM CONFIGURABLE_COMMAND");
                return cc;
            }
        }

        public override ConfigurableCommandInfo GetConfigurableCommand(int configurableCommandId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var cc = db.Query<ConfigurableCommandInfo>("SELECT * FROM CONFIGURABLE_COMMAND WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID", new { CONFIGURABLE_COMMAND_ID = configurableCommandId }).FirstOrDefault();
                if (cc == null)
                    throw new FileNotFoundException("Configurable command not found.");
                return cc;
            }
        }

        public override ConfigurableCommandInfo AddConfigurableCommand(ConfigurableCommandInfo configurableCommand)
        {
            string sql = "";
            using (var db = new SqlConnection(ConnectionString))
            {
                sql = @"
DECLARE @CONFIGURABLE_COMMAND_ID INT
SELECT @CONFIGURABLE_COMMAND_ID = NEXT VALUE FOR SEQ_CONFIGURABLE_COMMAND

INSERT INTO CONFIGURABLE_COMMAND (
    [CONFIGURABLE_COMMAND_ID],
    [DESCRIPTION],
    [COMMENT],
    [CLASS_NAME],
    [ENABLED_FLAG]
)
VALUES (
    @CONFIGURABLE_COMMAND_ID,
    @DESCRIPTION,
    @COMMENT,
    @CLASS_NAME,
    @ENABLED_FLAG
);
SELECT * FROM CONFIGURABLE_COMMAND WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID;";

                var cc = db.Query<ConfigurableCommandInfo>(sql, new
                {
                    @DESCRIPTION = configurableCommand.Description,
                    @COMMENT = configurableCommand.Comment,
                    @CLASS_NAME = configurableCommand.ClassName,
                    @ENABLED_FLAG = configurableCommand.EnabledFlag
                }).FirstOrDefault();
                return cc;
            }
        }

        public override void UpdateConfigurableCommand(int configurableCommandId, ConfigurableCommandInfo configurableCommand)
        {
            string sql = "";

            if (configurableCommandId != configurableCommand.ConfigurableCommandId)
                throw new Exception("Invalid configurableCommandId");

            using (var db = new SqlConnection(ConnectionString))
            {
                sql = @"
UPDATE CONFIGURABLE_COMMAND
SET
    [DESCRIPTION] = @DESCRIPTION,
    [COMMENT] = @COMMENT,
    [CLASS_NAME] = @CLASS_NAME,
    [ENABLED_FLAG] = @ENABLED_FLAG
WHERE
    CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID;";

                var rows = db.Execute(sql, new
                {
                    @CONFIGURABLE_COMMAND_ID = configurableCommandId,
                    @DESCRIPTION = configurableCommand.Description,
                    @COMMENT = configurableCommand.Comment,
                    @CLASS_NAME = configurableCommand.ClassName,
                    @ENABLED_FLAG = configurableCommand.EnabledFlag
                });
                if (rows == 0)
                    throw new FileNotFoundException("Unable to update configurable command.");
            }
        }

        public override void DeleteConfigurableCommand(int configurableCommandId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var cc = db.Query<ConfigurableCommandInfo>("SELECT * FROM CONFIGURABLE_COMMAND WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID", new { CONFIGURABLE_COMMAND_ID = configurableCommandId }).FirstOrDefault();
                var cls = GetClasses().First(c => c.ClassName.Equals(cc.ClassName, StringComparison.OrdinalIgnoreCase));

                if (cc == null)
                    throw new Exception("Configurable command not found.");

                if (cls.ClassType == ConfigurableCommandType.Loader)
                {
                    db.Execute(@"
DELETE FROM LOADER_COLUMN WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID;
DELETE FROM LOADER WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID;
DELETE FROM LOADER_PROBE_QUEUE WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID;", new { CONFIGURABLE_COMMAND_ID = configurableCommandId });
                }

                db.Execute(@"
DELETE FROM CONFIGURABLE_COMMAND_SCHEDULE WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID;
DELETE FROM CONFIGURABLE_COMMAND_QUEUE WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID;
DELETE FROM CONFIGURABLE_COMMAND_PROPERTY WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID;
DELETE FROM CONFIGURABLE_COMMAND WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID;", new { CONFIGURABLE_COMMAND_ID = configurableCommandId });

            }
        }

        #endregion

        #region Configurable Commands - Actions

        public override IEnumerable<ActionQueueInfo> GetActionQueue(string action = null, bool includeHistory = false)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var sql = "SELECT * FROM ACTION_QUEUE";
                var filters = new List<string>();
                if (action != null)
                    filters.Add("ACTION = @ACTION");
                if (!includeHistory)
                    filters.Add("STATUS = 'Ready'");

                if (filters.Any())
                    sql = $"{sql} WHERE {string.Join(" AND ", filters.ToArray())}";

                var q = db.Query<ActionQueueInfo>(sql, new
                {
                    ACTION = action
                });
                return q.OrderBy(q => q.ActionQueueId);
            }
        }

        public override ActionQueueInfo AddActionQueue(ActionQueueInfo item)
        {
            item.Status = ActionQueueStatus.Ready;

            using (var db = new SqlConnection(ConnectionString))
            {
                var sql = $@"
DECLARE @ACTION_QUEUE_ID INT
SELECT @ACTION_QUEUE_ID = NEXT VALUE FOR SEQ_ACTION_QUEUE

INSERT INTO ACTION_QUEUE (
    ACTION_QUEUE_ID,
    DUE_DT,
    BEGIN_DT,
    END_DT,
    ACTION,
    PARAMETERS,
    STATUS,
    EXCEPTION
)
SELECT
    @ACTION_QUEUE_ID,
    @DUE_DT,
    NULL,
    NULL,
    @ACTION,
    @PARAMETERS,
    @STATUS,
    NULL;

SELECT * FROM ACTION_QUEUE WHERE ACTION_QUEUE_ID = @ACTION_QUEUE_ID;";

                var aq = db.Query<ActionQueueInfo>(sql, new
                {
                    @DUE_DT = item.DueDt,
                    @ACTION = item.Action,
                    @PARAMETERS = item.Parameters,
                    @STATUS = item.Status.ToText()
                }).First();
                return aq;
            }
        }

        public override void SetActionQueueStatus(int actionQueueId, ActionQueueStatus actionQueueStatus, Exception ex = null)
        {
            using (var db = new SqlConnection(ConnectionString))
            {

                var sql = "UPDATE ACTION_QUEUE SET STATUS = @STATUS, EXCEPTION = @EXCEPTION WHERE ACTION_QUEUE_ID = @ACTION_QUEUE_ID; UPDATE ACTION_QUEUE SET BEGIN_DT = GETDATE() WHERE ACTION_QUEUE_ID = @ACTION_QUEUE_ID AND BEGIN_DT IS NULL;";
                db.Execute(sql, new
                {
                    ACTION_QUEUE_ID = actionQueueId,
                    STATUS = actionQueueStatus.ToText(),
                    EXCEPTION = ex != null ? ex.Message : null
                });

                if (actionQueueStatus == ActionQueueStatus.Running)
                {
                    sql = "UPDATE ACTION_QUEUE SET BEGIN_DT = GETDATE() WHERE ACTION_QUEUE_ID = @ACTION_QUEUE_ID;";
                    db.Execute(sql, new
                    {
                        ACTION_QUEUE_ID = actionQueueId,
                        STATUS = actionQueueStatus.ToText()
                    });
                }

                if (actionQueueStatus == ActionQueueStatus.Aborted || actionQueueStatus == ActionQueueStatus.Failure || actionQueueStatus == ActionQueueStatus.Success)
                {
                    sql = "UPDATE ACTION_QUEUE SET END_DT = GETDATE() WHERE ACTION_QUEUE_ID = @ACTION_QUEUE_ID;";
                    db.Execute(sql, new
                    {
                        ACTION_QUEUE_ID = actionQueueId,
                        STATUS = actionQueueStatus.ToText()
                    });
                }

            }
        }

        public override void DeleteActionQueue(int actionQueueId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                db.Execute("DELETE FROM ACTION_QUEUE WHERE ACTION_QUEUE_ID = @ACTION_QUEUE_ID", new { ACTION_QUEUE_ID = actionQueueId });
            }
        }

        #endregion

        #region Configurable Commands - Loaders

        public override LoaderInfo GetLoader(int configurableCommandId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var l = db.Query<LoaderInfo>("SELECT * FROM LOADER WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID", new { CONFIGURABLE_COMMAND_ID = configurableCommandId }).FirstOrDefault();

                if (l == null)
                    throw new FileNotFoundException("Loader not found.");

                return l;
            }
        }

        public override void AddLoader(LoaderInfo loader)
        {
            string sql = "";
            using (var db = new SqlConnection(ConnectionString))
            {
                sql = @"
INSERT INTO LOADER (
    [CONFIGURABLE_COMMAND_ID],
    [SERVER_NAME],
    [TARGET_NAME],
    [TARGET_BEHAVIOUR],
    [BEFORE_ROW_PROCESSING_SQL],
    [ROW_PROCESSING_BEHAVIOUR],
    [AFTER_ROW_PROCESSING_SQL]
)
VALUES (
    @CONFIGURABLE_COMMAND_ID,
    @SERVER_NAME,
    @TARGET_NAME,
    @TARGET_BEHAVIOUR,
    @BEFORE_ROW_PROCESSING_SQL,
    @ROW_PROCESSING_BEHAVIOUR,
    @AFTER_ROW_PROCESSING_SQL
);";

                var l = db.Execute(sql, new
                {
                    @CONFIGURABLE_COMMAND_ID = loader.ConfigurableCommandId,
                    @SERVER_NAME = loader.ServerName,
                    @TARGET_NAME = loader.TargetName,
                    @TARGET_BEHAVIOUR = loader.TargetBehaviour.ToText(),
                    @BEFORE_ROW_PROCESSING_SQL = loader.BeforeRowProcessingSql,
                    @ROW_PROCESSING_BEHAVIOUR = loader.RowProcessingBehaviour.ToText(),
                    @AFTER_ROW_PROCESSING_SQL = loader.AfterRowProcessingSql
                });
            }
        }

        public override void UpdateLoader(int configurableCommandId, LoaderInfo loader)
        {
            string sql = "";

            if (configurableCommandId != loader.ConfigurableCommandId)
                throw new Exception("Invalid configurableCommandId");

            using (var db = new SqlConnection(ConnectionString))
            {
                sql = @"
UPDATE LOADER
SET
    [SERVER_NAME] = @SERVER_NAME,
    [TARGET_NAME] = @TARGET_NAME,
    [TARGET_BEHAVIOUR] = @TARGET_BEHAVIOUR,
    [BEFORE_ROW_PROCESSING_SQL] = @BEFORE_ROW_PROCESSING_SQL,
    [ROW_PROCESSING_BEHAVIOUR] = @ROW_PROCESSING_BEHAVIOUR,
    [AFTER_ROW_PROCESSING_SQL] = @AFTER_ROW_PROCESSING_SQL
WHERE
    CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID;";

                var rows = db.Execute(sql, new
                {
                    @CONFIGURABLE_COMMAND_ID = configurableCommandId,
                    @SERVER_NAME = loader.ServerName,
                    @TARGET_NAME = loader.TargetName,
                    @TARGET_BEHAVIOUR = loader.TargetBehaviour.ToText(),
                    @BEFORE_ROW_PROCESSING_SQL = loader.BeforeRowProcessingSql,
                    @ROW_PROCESSING_BEHAVIOUR = loader.RowProcessingBehaviour.ToText(),
                    @AFTER_ROW_PROCESSING_SQL = loader.AfterRowProcessingSql
                });
                if (rows == 0)
                    throw new Exception("Unable to update loader.");
            }
        }

        public override IList<LoaderColumnInfo> GetLoaderColumns(int configurableCommandId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var cc = db.Query<LoaderInfo>("SELECT * FROM CONFIGURABLE_COMMAND WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID", new { CONFIGURABLE_COMMAND_ID = configurableCommandId }).FirstOrDefault();
                if (cc == null)
                    throw new Exception("Loader not found.");

                var cols = db.Query<LoaderColumnInfo>("SELECT * FROM LOADER_COLUMN WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID ORDER BY SEQ", new { CONFIGURABLE_COMMAND_ID = cc.ConfigurableCommandId });
                return cols.ToList();
            }
        }

        public override void UpdateLoaderColumns(int configurableCommandId, IEnumerable<LoaderColumnInfo> columns)
        {
            foreach (var column in columns)
            {
                if (column.ConfigurableCommandId != configurableCommandId)
                    throw new Exception("Column information is for incorrect loader.");
            }

            var now = DateTime.Now;

            using (var db = new SqlConnection(ConnectionString))
            {
                var rows = db.Execute("DELETE FROM LOADER_COLUMN WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID", new { CONFIGURABLE_COMMAND_ID = configurableCommandId });

                foreach (var column in columns)
                {
                    if (column.DataLength == 0)
                        column.DataLength = -1;

                    db.Execute(@"
INSERT INTO LOADER_COLUMN (
    CONFIGURABLE_COMMAND_ID,
    COLUMN_NAME,
    SEQ,
    PRIMARY_KEY,
    DATA_TYPE,
    DATA_LENGTH,
    SELECTED,
    UPDATED_DT
) SELECT
    @CONFIGURABLE_COMMAND_ID,
    @COLUMN_NAME,
    @SEQ,
    @PRIMARY_KEY,
    @DATA_TYPE,
    @DATA_LENGTH,
    @SELECTED,
    @UPDATED_DT", new
                    {
                        CONFIGURABLE_COMMAND_ID = configurableCommandId,
                        COLUMN_NAME = column.ColumnName,
                        SEQ = column.Order,
                        PRIMARY_KEY = column.PrimaryKey,
                        DATA_TYPE = column.DataType.ToText(),
                        DATA_LENGTH = column.DataLength,
                        SELECTED = column.Selected,
                        UPDATED_DT = now
                    });
                }
            }
        }

        public override IEnumerable<int> GetProbeLoaderQueue()
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var probesDue = db.Query<int>("SELECT CONFIGURABLE_COMMAND_ID FROM LOADER_PROBE_QUEUE;");
                return probesDue;
            }
        }

        public override void AddProbeLoaderQueue(int configurableCommandId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                // Get loader
                var loader = db.Query<LoaderInfo>("SELECT * FROM LOADER WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID", new { CONFIGURABLE_COMMAND_ID = configurableCommandId }).FirstOrDefault();
                if (loader == null)
                    throw new Exception("Invalid loader!");

                db.Execute(@"
IF NOT EXISTS (SELECT NULL FROM LOADER_PROBE_QUEUE WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID)
	INSERT INTO LOADER_PROBE_QUEUE VALUES (@CONFIGURABLE_COMMAND_ID);
", new
                {
                    CONFIGURABLE_COMMAND_ID = configurableCommandId
                });
            }
        }

        public override void DeleteProbeLoaderQueue(int configurableCommandId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                db.Execute("DELETE FROM LOADER_PROBE_QUEUE WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID", new
                {
                    CONFIGURABLE_COMMAND_ID = configurableCommandId
                });
            }
        }

        #endregion

        #region Configurable Commands - Classes

        public override IEnumerable<ConfigurableCommandClassInfo> GetClasses()
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var obj = db.Query<ConfigurableCommandClassInfo>("SELECT * FROM CONFIGURABLE_COMMAND_CLASS");
                return obj;
            }
        }

        public override void AddClass(ConfigurableCommandClassInfo configurableCommandClass)
        {
            using (var connection = new SqlConnection(ConnectionString))
            {
                connection.Execute("INSERT INTO CONFIGURABLE_COMMAND_CLASS (CLASS_NAME, CLASS_DESC, CLASS_TYPE, TYPE_NAME) SELECT @CLASS_NAME, @CLASS_DESC, @CLASS_TYPE, @TYPE_NAME", new
                {
                    CLASS_NAME = configurableCommandClass.ClassName,
                    CLASS_DESC = configurableCommandClass.ClassDesc,
                    CLASS_TYPE = configurableCommandClass.ClassType.ToText(),
                    TYPE_NAME = configurableCommandClass.TypeName
                });
            }
        }

        public override void DeleteClass(string configurableCommandClassName)
        {
            using (var connection = new SqlConnection(ConnectionString))
            {
                connection.Execute("DELETE FROM CONFIGURABLE_COMMAND_CLASS WHERE CLASS_NAME = @CLASS_NAME", new
                {
                    CLASS_NAME = configurableCommandClassName
                });
            }
        }

        #endregion

        #region Configurable Commands - Properties

        public override IEnumerable<ConfigurableCommandProperty> GetConfigurableCommandProperties(int configurableCommandId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var properties = db.Query<ConfigurableCommandProperty>("SELECT * FROM CONFIGURABLE_COMMAND_PROPERTY WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID", new { CONFIGURABLE_COMMAND_ID = configurableCommandId });
                return properties;
            }
        }

        public override void SetConfigurableCommandProperty(int configurableCommandId, string propertyName, string propertyValue)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var cc = GetConfigurableCommand(configurableCommandId);

                // Update new value
                var props = db.Execute(@"
IF EXISTS (
    SELECT
        NULL
    FROM
        CONFIGURABLE_COMMAND_PROPERTY
    WHERE
        CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID AND
        PROPERTY_NAME = @PROPERTY_NAME
)
BEGIN
    UPDATE
        CONFIGURABLE_COMMAND_PROPERTY
    SET
        PROPERTY_VALUE = @PROPERTY_VALUE
    WHERE
        CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID AND
    PROPERTY_NAME = @PROPERTY_NAME;
END
ELSE
BEGIN
    INSERT INTO
        CONFIGURABLE_COMMAND_PROPERTY (
            CONFIGURABLE_COMMAND_ID, PROPERTY_NAME, PROPERTY_VALUE
        )
    SELECT
        @CONFIGURABLE_COMMAND_ID,
        @PROPERTY_NAME,
        @PROPERTY_VALUE
END",
                    new
                    {
                        CONFIGURABLE_COMMAND_ID = cc.ConfigurableCommandId,
                        PROPERTY_NAME = propertyName,
                        PROPERTY_VALUE = propertyValue
                    }
                    );
            }
        }

        public override void UnsetConfigurableCommandProperty(int configurableCommandId, string propertyName)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var cc = GetConfigurableCommand(configurableCommandId);

                var sql = @"DELETE FROM CONFIGURABLE_COMMAND_PROPERTY WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID AND PROPERTY_NAME = @PROPERTY_NAME";
                db.Execute(
                    sql,
                    new
                    {
                        CONFIGURABLE_COMMAND_ID = cc.ConfigurableCommandId,
                        PROPERTY_NAME = propertyName
                    });
            }
        }

        #endregion

        #region Configurable Commands - Schedules

        public override IEnumerable<ConfigurableCommandScheduleInfo> GetConfigurableCommandSchedules()
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var schedules = db.Query<ConfigurableCommandScheduleInfo>("SELECT * FROM CONFIGURABLE_COMMAND_SCHEDULE");
                return schedules;
            }
        }

        public override IEnumerable<ConfigurableCommandScheduleInfo> GetConfigurableCommandSchedules(int configurableCommandId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var cc = db.Query<Sara.Lib.Models.ConfigurableCommand.ConfigurableCommandInfo>("SELECT * FROM CONFIGURABLE_COMMAND WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID", new { CONFIGURABLE_COMMAND_ID = configurableCommandId }).FirstOrDefault();

                if (cc == null)
                    throw new Exception("Configurable command not found.");

                var schedules = db.Query<ConfigurableCommandScheduleInfo>("SELECT * FROM CONFIGURABLE_COMMAND_SCHEDULE WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID", new { CONFIGURABLE_COMMAND_ID = configurableCommandId });
                return schedules;
            }
        }

        public override ConfigurableCommandScheduleInfo GetConfigurableCommandSchedule(int configurableCommandScheduleId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var s = db.Query<ConfigurableCommandScheduleInfo>("SELECT * FROM CONFIGURABLE_COMMAND_SCHEDULE WHERE CONFIGURABLE_COMMAND_SCHEDULE_ID = @CONFIGURABLE_COMMAND_SCHEDULE_ID", new { CONFIGURABLE_COMMAND_SCHEDULE_ID = configurableCommandScheduleId }).FirstOrDefault();
                if (s == null)
                    throw new Exception("Schedule not found.");

                return s;
            }
        }

        public override ConfigurableCommandScheduleInfo AddConfigurableCommandSchedule(ConfigurableCommandScheduleInfo schedule)
        {
            ConfigurableCommandScheduleInfo s = null;
            using (var db = new SqlConnection(ConnectionString))
            {
                s = db.Query<ConfigurableCommandScheduleInfo>(@"
DECLARE @CONFIGURABLE_COMMAND_SCHEDULE_ID INT
SELECT @CONFIGURABLE_COMMAND_SCHEDULE_ID = NEXT VALUE FOR SEQ_CONFIGURABLE_COMMAND_SCHEDULE

INSERT INTO CONFIGURABLE_COMMAND_SCHEDULE (CONFIGURABLE_COMMAND_SCHEDULE_ID, CONFIGURABLE_COMMAND_ID, CRON, ONE_TIME, ENABLED_FLAG)
SELECT @CONFIGURABLE_COMMAND_SCHEDULE_ID, @CONFIGURABLE_COMMAND_ID, @CRON, @ONE_TIME, @ENABLED_FLAG;
SELECT * FROM CONFIGURABLE_COMMAND_SCHEDULE WHERE CONFIGURABLE_COMMAND_SCHEDULE_ID = @CONFIGURABLE_COMMAND_SCHEDULE_ID", new { CONFIGURABLE_COMMAND_ID = schedule.ConfigurableCommandId, CRON = schedule.Cron, ONE_TIME = schedule.OneTime, ENABLED_FLAG = schedule.EnabledFlag }).First();

                return s;
            }
        }

        public override void UpdateConfigurableCommandSchedule(int configurableCommandScheduleId, ConfigurableCommandScheduleInfo schedule)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var s = db.Query<ConfigurableCommandScheduleInfo>("SELECT * FROM CONFIGURABLE_COMMAND_SCHEDULE WHERE CONFIGURABLE_COMMAND_SCHEDULE_ID = @CONFIGURABLE_COMMAND_SCHEDULE_ID", new { CONFIGURABLE_COMMAND_SCHEDULE_ID = configurableCommandScheduleId }).FirstOrDefault();
                if (s == null)
                    throw new Exception("Configurable command not found");

                if (configurableCommandScheduleId != s.ConfigurableCommandScheduleId)
                    throw new Exception("Invalid configurableCommandScheduleId.");

                db.Execute(@"
UPDATE CONFIGURABLE_COMMAND_SCHEDULE
SET
    CRON = @CRON,
    ONE_TIME = @ONE_TIME,
    ENABLED_FLAG = @ENABLED_FLAG
WHERE
    CONFIGURABLE_COMMAND_SCHEDULE_ID = @CONFIGURABLE_COMMAND_SCHEDULE_ID;", new { CONFIGURABLE_COMMAND_SCHEDULE_ID = schedule.ConfigurableCommandScheduleId, CRON = schedule.Cron, ONE_TIME = schedule.OneTime, ENABLED_FLAG = schedule.EnabledFlag });
            }
        }

        public override void DeleteConfigurableCommandSchedule(int configurableCommandScheduleId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var s = db.Query<ConfigurableCommandScheduleInfo>("SELECT * FROM CONFIGURABLE_COMMAND_SCHEDULE WHERE CONFIGURABLE_COMMAND_SCHEDULE_ID = @CONFIGURABLE_COMMAND_SCHEDULE_ID", new { CONFIGURABLE_COMMAND_SCHEDULE_ID = configurableCommandScheduleId }).FirstOrDefault();
                if (s == null)
                    throw new Exception("Configurable command not found");

                db.Execute("DELETE FROM CONFIGURABLE_COMMAND_SCHEDULE WHERE CONFIGURABLE_COMMAND_SCHEDULE_ID = @CONFIGURABLE_COMMAND_SCHEDULE_ID", new { CONFIGURABLE_COMMAND_SCHEDULE_ID = s.ConfigurableCommandScheduleId });
            }
        }

        #endregion

        #region Configurable Command Preconditions

        public override IEnumerable<ConfigurableCommandPreconditionInfo> GetConfigurableCommandPreconditions()
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var preconditions = db.Query<ConfigurableCommandPreconditionInfo>("SELECT * FROM CONFIGURABLE_COMMAND_PRECONDITION");
                return preconditions;
            }
        }

        public override IEnumerable<ConfigurableCommandPreconditionInfo> GetConfigurableCommandPreconditions(int configurableCommandId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var cc = db.Query<Sara.Lib.Models.ConfigurableCommand.ConfigurableCommandInfo>("SELECT * FROM CONFIGURABLE_COMMAND WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID", new { CONFIGURABLE_COMMAND_ID = configurableCommandId }).FirstOrDefault();

                if (cc == null)
                    throw new Exception("Configurable command not found.");

                var preconditions = db.Query<ConfigurableCommandPreconditionInfo>("SELECT * FROM CONFIGURABLE_COMMAND_PRECONDITION WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID", new { CONFIGURABLE_COMMAND_ID = configurableCommandId });
                return preconditions;
            }
        }

        public override void SetConfigurableCommandPrecondition(ConfigurableCommandPreconditionInfo precondition)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                // create / update precondition
                db.Execute(@"
IF EXISTS (SELECT NULL FROM CONFIGURABLE_COMMAND_PRECONDITION WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID AND PRECONDITION_ID = @PRECONDITION_ID)
BEGIN
    -- UPDATE
    UPDATE
        CONFIGURABLE_COMMAND_PRECONDITION
    SET
        SUCCESS_FLAG = @SUCCESS_FLAG,
        AUTO_SCHEDULE_FLAG = @AUTO_SCHEDULE_FLAG
    WHERE
        CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID AND
        PRECONDITION_ID = @PRECONDITION_ID
END
ELSE
BEGIN
    INSERT INTO
        CONFIGURABLE_COMMAND_PRECONDITION
    SELECT
        @CONFIGURABLE_COMMAND_ID,
        @PRECONDITION_ID,
        @SUCCESS_FLAG,
        @AUTO_SCHEDULE_FLAG
END
", new
                {
                    CONFIGURABLE_COMMAND_ID = precondition.ConfigurableCommandId,
                    PRECONDITION_ID = precondition.PreconditionId,
                    SUCCESS_FLAG = precondition.SuccessFlag,
                    AUTO_SCHEDULE_FLAG = precondition.AutoScheduleFlag
                });
            }
        }

        public override void UnsetConfigurableCommandPrecondition(int configurableCommandId, int preconditionId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                db.Execute("DELETE FROM CONFIGURABLE_COMMAND_PRECONDITION WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID AND PRECONDITION_ID = @PRECONDITION_ID", new { CONFIGURABLE_COMMAND_ID = configurableCommandId, PRECONDITION_ID = preconditionId });
            }
        }

        #endregion

        #region Configurable Command Schedule Execution

        public override void ScheduleConfigurableCommand(int configurableCommandId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var cc = db.Query<Sara.Lib.Models.ConfigurableCommand.ConfigurableCommandInfo>("SELECT * FROM CONFIGURABLE_COMMAND WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID", new { CONFIGURABLE_COMMAND_ID = configurableCommandId }).FirstOrDefault();
                if (cc == null)
                    throw new Exception("Configurable command not found.");

                ConfigurableCommandScheduleInfo s = new ConfigurableCommandScheduleInfo();
                s.ConfigurableCommandId = cc.ConfigurableCommandId.Value;
                s.OneTime = true;
                s.Cron = "* * * * *";

                var schedule = db.Query<ConfigurableCommandScheduleInfo>(@"
DECLARE @CONFIGURABLE_COMMAND_SCHEDULE_ID INT
SELECT @CONFIGURABLE_COMMAND_SCHEDULE_ID = NEXT VALUE FOR SEQ_CONFIGURABLE_COMMAND_SCHEDULE

INSERT INTO CONFIGURABLE_COMMAND_SCHEDULE (
    CONFIGURABLE_COMMAND_SCHEDULE_ID,
    CONFIGURABLE_COMMAND_ID,
    CRON,
    ONE_TIME
)
VALUES (
    @CONFIGURABLE_COMMAND_SCHEDULE_ID,
    @CONFIGURABLE_COMMAND_ID,
    @CRON,
    @ONE_TIME
);", new
                {
                    @CONFIGURABLE_COMMAND_ID = cc.ConfigurableCommandId,
                    @CRON = s.Cron,
                    @ONE_TIME = s.OneTime
                }).FirstOrDefault();
            }
        }

        public override void AbortConfigurableCommand(int logId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var logs = db.Execute("UPDATE LOG_HEADER SET CANCELLED_FLAG = 1 WHERE LOG_ID = @LOG_ID", new { LOG_ID = logId });
            }
        }

        public override IEnumerable<ConfigurableCommandQueueInfo> GetConfigurableCommandQueue()
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                return db.Query<ConfigurableCommandQueueInfo>("SELECT * FROM CONFIGURABLE_COMMAND_QUEUE");
            }
        }

        public override IEnumerable<ConfigurableCommandQueueInfo> LockDueQueueForExecution()
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var itemsDue = db.Query<ConfigurableCommandQueueInfo>(@"
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN TRANSACTION

    -- FIRST DELETE ANY QUEUE ENTRIES BELONGING TO DISABLED COMMANDS. WE DON'T WANT TO RUN THESE
    DELETE FROM
        CONFIGURABLE_COMMAND_QUEUE
    WHERE
        EXISTS (
            SELECT
                NULL
            FROM
                CONFIGURABLE_COMMAND CC
            WHERE
                ENABLED_FLAG = 0 AND CONFIGURABLE_COMMAND_QUEUE.CONFIGURABLE_COMMAND_ID = CC.CONFIGURABLE_COMMAND_ID
        ); 

	DECLARE @RUN_IDS TABLE(CONFIGURABLE_COMMAND_ID INT)
	INSERT INTO
        @RUN_IDS
    SELECT
        CONFIGURABLE_COMMAND_ID
    FROM
        CONFIGURABLE_COMMAND_QUEUE T1
    WHERE
        NEXT_DT <= @NOW AND
        RUNNING = 0 AND
        NOT EXISTS
        (
            -- DON'T START ANY COMMAND THAT HAS A PRECONDITION, AND THAT PRECONDITION
            -- HAS AN UNFINISHED QUEUE ENTRY. ALL PRECONDITION COMMANDS MUST COMPLETE
            -- BEFORE A COMMAND WITH PRECONDITIONS CAN START.
            SELECT
                PRE.*
            FROM
	            CONFIGURABLE_COMMAND_PRECONDITION PRE
            INNER JOIN
	            CONFIGURABLE_COMMAND_QUEUE Q
            ON
	            PRE.PRECONDITION_ID = Q.CONFIGURABLE_COMMAND_ID AND
	            Q.NEXT_DT <= @NOW
            WHERE
                T1.CONFIGURABLE_COMMAND_ID = PRE.CONFIGURABLE_COMMAND_ID
        )
	
	UPDATE
		CCQ
	SET
		RUNNING = 1
	FROM
		CONFIGURABLE_COMMAND_QUEUE CCQ
	INNER JOIN
		@RUN_IDS IDS
	ON
		CCQ.CONFIGURABLE_COMMAND_ID = IDS.CONFIGURABLE_COMMAND_ID

	SELECT
		CCQ.*
	FROM
		CONFIGURABLE_COMMAND_QUEUE CCQ
	INNER JOIN
		@RUN_IDS IDS
	ON
		CCQ.CONFIGURABLE_COMMAND_ID = IDS.CONFIGURABLE_COMMAND_ID

COMMIT TRANSACTION", new { NOW = DateTime.Now });

                return itemsDue;
            }
        }

        public override void RemoveQueue(int configurableCommandId)
        {
            // Remove queue entry
            using (var db = new SqlConnection(ConnectionString))
            {
                db.Execute("DELETE FROM CONFIGURABLE_COMMAND_QUEUE WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID", new
                {
                    CONFIGURABLE_COMMAND_ID = configurableCommandId
                });
            }
        }

        public override bool OnScheduleConfigurableCommand(Scheduler scheduler, int configurableCommandId)
        {
            var nextDt = scheduler.NextDt[configurableCommandId];

            using (var db = new SqlConnection(ConnectionString))
            {
                var sql = @"
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

BEGIN TRANSACTION
    DECLARE @RUNNING INT
    DECLARE @NEXT_DT DATETIME
    SELECT @RUNNING = RUNNING, @NEXT_DT = NEXT_DT FROM CONFIGURABLE_COMMAND_QUEUE WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID

    IF @RUNNING IS NULL	-- QUEUE DOESN'T EXIST - INSERT
	BEGIN
		INSERT INTO CONFIGURABLE_COMMAND_QUEUE SELECT @CONFIGURABLE_COMMAND_ID, @NEW_DT, 0
	END
	ELSE IF @RUNNING = 0 AND @NEXT_DT <> @NEW_DT AND @NEXT_DT > @START_DT  	-- EXISTING QUEUE ENTRY PRESENT, IN FUTURE AND DIFFERENT TO CALCULATED NEXT DT. OK TO CHANGE
	BEGIN
		UPDATE CONFIGURABLE_COMMAND_QUEUE SET NEXT_DT = @NEW_DT WHERE CONFIGURABLE_COMMAND_ID = @CONFIGURABLE_COMMAND_ID
	END
COMMIT TRANSACTION
";

                int rows = db.Execute(sql, new
                {
                    CONFIGURABLE_COMMAND_ID = configurableCommandId,
                    NEW_DT = nextDt,
                    START_DT = scheduler.StartDate
                });
                if (rows >= 0)
                    // Has modified the schedule
                    return true;
                else
                    // Not modified schedule
                    return false;
            }
        }

        public override void OnRemoveOneTimeSchedule(int configurableCommandScheduleId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                db.Execute("DELETE FROM CONFIGURABLE_COMMAND_SCHEDULE WHERE CONFIGURABLE_COMMAND_SCHEDULE_ID = @CONFIGURABLE_COMMAND_SCHEDULE_ID", new { CONFIGURABLE_COMMAND_SCHEDULE_ID = configurableCommandScheduleId });
            }
        }

        public override void ResetQueues(int? maximumCommandExecutionMins = 60)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                db.Execute("DELETE FROM LOADER_PROBE_QUEUE");
                db.Execute("DELETE FROM CONFIGURABLE_COMMAND_QUEUE");

                // Remove any running queue entries. The command executer has a fixed timeout
                // (default 60 mins), so no process should ever run over this.
                // Code below treats any such commands as not possibly still running, and
                // marks the status as failed, and manually inserts a log item entry.

                // Typically commands will 'appear' as still running over 1 hour following
                // a hard restart on the app server, so this API method should be executed
                // following a hard reset of the app server.
                db.Execute(@"
DECLARE @LOG_IDS TABLE(
    LOG_ID INT
)

INSERT INTO @LOG_IDS
SELECT
    LOG_ID
FROM
	LOG_HEADER
WHERE
	SUCCESS_FLAG IS NULL AND
	LOG_ID IN (
		SELECT
			LOG_ID
		FROM
		(
			SELECT
				LOG_ID,
				MIN(LOG_DT) MIN_LOG_DT
			FROM
				LOG_ITEM
			GROUP BY
				LOG_ID
		) L
		WHERE
			DATEDIFF(MINUTE, MIN_LOG_DT, GETDATE()) > @MAXIMUM_COMMAND_EXECUTION_MINS
    );

UPDATE
	LOG_HEADER
SET
    SUCCESS_FLAG = 0,
    CANCELLED_FLAG = 1
WHERE
    LOG_ID IN (SELECT LOG_ID FROM @LOG_IDS);

INSERT INTO
    LOG_ITEM (LOG_ITEM_ID, LOG_ID, LOG_DT, EXECUTABLE, CLASS, METHOD, LOG_TYPE, MESSAGE, ROWS_AFFECTED)
SELECT
	NEXT VALUE FOR SEQ_LOG_ITEM, LOG_ID,
	GETDATE(),
	@EXECUTABLE,
	@CLASS,
	@METHOD,
	@LOG_TYPE,
	'Command status manually set to ABORT. Execution of this command may have been terminated unexpectedly on the server.',
	NULL
FROM
	@LOG_IDS;", new
                {
                    MAXIMUM_COMMAND_EXECUTION_MINS = maximumCommandExecutionMins,
                    EXECUTABLE = this.GetType().Assembly.GetName().Name,
                    CLASS = this.GetType().Name,
                    METHOD = System.Reflection.MethodBase.GetCurrentMethod().Name,
                    LOG_TYPE = "ABORT"
                }, null, 60 * 10);
            }
        }

        #endregion

        #region Datasets

        public override IEnumerable<DatasetInfo> GetDatasets(bool includeInactive = false)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var sql = "SELECT * FROM DATASET WHERE ACTIVE = 1";
                if (includeInactive)
                    sql = "SELECT * FROM DATASET";
                var datasets = db.Query<DatasetInfo>(sql);
                return datasets;
            }
        }

        public override DatasetSummaryInfo GetDataset(string category, string dataset)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var ds = db.Query<DatasetSummaryInfo>("SELECT * FROM DATASET_SUMMARY WHERE INTERNAL = 0 AND ACTIVE = 1 AND CATEGORY = @CATEGORY AND DATASET = @DATASET", new
                {
                    CATEGORY = category,
                    DATASET = dataset
                }).FirstOrDefault();

                if (ds == null)
                    throw new FileNotFoundException("Dataset not found.");

                ds.Columns = GetColumns(ds);
                ds.Parameters = GetParameters(ds);
                ds.Ranking = GetDatasetRanking(ds);
                ds.Top3Users = GetTop3Users(ds);
                ds.DownloadSecs = GetDownloadSeconds(ds);

                return ds;
            }
        }

        public override DatasetInfo GetDataset(int datasetId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var dataset = db.Query<DatasetInfo>("SELECT * FROM DATASET WHERE DATASET_ID = @DATASET_ID", new { DATASET_ID = datasetId }).First();
                return dataset;
            }
        }

        public override DatasetInfo AddDataset(DatasetInfo dataset)
        {
            string sql = "";
            using (var db = new SqlConnection(ConnectionString))
            {
                sql = @"
DECLARE @DATASET_ID INT
SELECT @DATASET_ID = NEXT VALUE FOR SEQ_DATASET

INSERT INTO DATASET (
    [DATASET_ID],
    [CATEGORY],
    [DATASET],
    [DESCRIPTION],
    [SERVER_NAME],
    [SOURCE_NAME],
    [DISPLAY_GROUP],
    [WRITEABLE],
    [ACTIVE],
    [INTERNAL],
    [FORWARD_DATASET_ID],
    [OWNER]
)
VALUES (
    @DATASET_ID,
    @CATEGORY,
    @DATASET,
    @DESCRIPTION,
    @SERVER_NAME,
    @SOURCE_NAME,
    @DISPLAY_GROUP,
    @WRITEABLE,
    @ACTIVE,
    @INTERNAL,
    @FORWARD_DATASET_ID,
    @OWNER
);
SELECT * FROM DATASET WHERE DATASET_ID = @DATASET_ID;";

                var obj = db.Query<DatasetInfo>(sql, new
                {
                    @CATEGORY = dataset.Category,
                    @DATASET = dataset.Dataset,
                    @DESCRIPTION = dataset.Description,
                    @SERVER_NAME = dataset.ServerName,
                    @SOURCE_NAME = dataset.SourceName,
                    @DISPLAY_GROUP = dataset.DisplayGroup,
                    @WRITEABLE = dataset.Writeable,
                    @ACTIVE = dataset.Active,
                    @INTERNAL = dataset.Internal,
                    @FORWARD_DATASET_ID = dataset.ForwardDatasetId,
                    @OWNER = dataset.Owner
                }).FirstOrDefault();
                return obj;
            }

        }
        public override void UpdateDataset(int datasetId, DatasetInfo dataset)
        {
            string sql = "";

            if (datasetId != dataset.DatasetId)
                throw new Exception("Invalid datasetId");

            using (var db = new SqlConnection(ConnectionString))
            {
                sql = @"
UPDATE DATASET
SET
    [CATEGORY] = @CATEGORY,
    [DATASET] = @DATASET,
    [DESCRIPTION] = @DESCRIPTION,
    [SERVER_NAME] = @SERVER_NAME,
    [SOURCE_NAME] = @SOURCE_NAME,
    [DISPLAY_GROUP] = @DISPLAY_GROUP,
    [WRITEABLE] = @WRITEABLE,
    [ACTIVE] = @ACTIVE,
    [INTERNAL] = @INTERNAL,
    [FORWARD_DATASET_ID] = @FORWARD_DATASET_ID,
    [OWNER] = @OWNER
WHERE
    DATASET_ID = @DATASET_ID;";

                var rows = db.Execute(sql, new
                {
                    @DATASET_ID = datasetId,
                    @CATEGORY = dataset.Category,
                    @DATASET = dataset.Dataset,
                    @DESCRIPTION = dataset.Description,
                    @SERVER_NAME = dataset.ServerName,
                    @SOURCE_NAME = dataset.SourceName,
                    @DISPLAY_GROUP = dataset.DisplayGroup,
                    @WRITEABLE = dataset.Writeable,
                    @ACTIVE = dataset.Active,
                    @INTERNAL = dataset.Internal,
                    @FORWARD_DATASET_ID = dataset.ForwardDatasetId,
                    @OWNER = dataset.Owner
                });
                if (rows == 0)
                    throw new Exception("Unable to update dataset.");
            }
        }

        public override void DeleteDataset(int datasetId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var dataset = db.Query<DatasetInfo>("SELECT * FROM DATASET WHERE DATASET_ID = @DATASET_ID", new { DATASET_ID = datasetId }).FirstOrDefault();
                if (dataset == null)
                    throw new Exception("Dataset not found.");

                db.Execute(@"DELETE FROM DATASET WHERE DATASET_ID = @DATASET_ID", new { DATASET_ID = datasetId });
            }
        }

        public override IEnumerable<DatasetAuditInfo> GetDatasetAudit(string category, string dataset, string action)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var sql = @"SELECT * FROM DATASET_AUDIT WHERE CATEGORY = @CATALOG_NAME AND DATASET  = @OBJECT_NAME AND ACTION = @ACTION AND DATEDIFF(dd, AUDIT_DT, GETDATE()) < 35 ";
                var data = db.Query<DatasetAuditInfo>(sql, new
                {
                    CATALOG_NAME = category,
                    OBJECT_NAME = dataset,
                    ACTION = action
                });
                return data;
            }
        }

        public override IEnumerable<DatasetDependencyInfo> GetDatasetDependencies(string objectName, string direction)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var sql = @"SELECT * FROM TVF_GET_DEPENDENCIES(@OBJECT_NAME, @DIRECTION)";
                var data = db.Query<DatasetDependencyInfo>(sql, new
                {
                    OBJECT_NAME = objectName,
                    DIRECTION = direction
                });
                return data;
            }

        }

        public override string GetObjectDefinition(string objectName)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var sql = @"SELECT TOP 1 OBJECT_TYPE FROM SERVER_OBJECT WHERE OBJECT_NAME = @OBJECT_NAME";
                var objectType = db.ExecuteScalar<string>(sql, new
                {
                    OBJECT_NAME = objectName
                });

                string data;

                if (objectType == "BASE TABLE")
                {
                    // for base tables, we display the load information in last 7 days.
                    sql = @"SELECT * FROM GET_LOADER_HISTORY_FOR_OBJECT(@SOURCE_NAME, 7) ORDER BY START_DT DESC";
                    var results = db.Query(sql, new
                    {
                        SOURCE_NAME = objectName
                    });
                    char tab = '\t';
                    var resultsRows = string.Join(Environment.NewLine, results.ToList().Select(r => $"{r.START_DT}{tab}{r.END_DT}{tab}{r.LOG_STATUS}{tab}{r.ROWS_AFFECTED}"));
                    data = $@"
LOADER HISTORY FOR LAST 7 DAYS
==============================

START_DT              {tab}END_DT                {tab}STATUS{tab}ROWS
--------              {tab}------                {tab}------{tab}----
{resultsRows}";
                }
                else if (objectType == "MATERIALISED VIEW")
                {
                    data = "Materialised views are simply cached copies of the preceding item in the data flow.";
                }
                else
                {
                    sql = @"SELECT TOP 1 DEFINITION FROM SERVER_OBJECT WHERE OBJECT_NAME = @OBJECT_NAME";
                    data = db.ExecuteScalar<string>(sql, new
                    {
                        OBJECT_NAME = objectName
                    });
                }
                return data;
            }
        }

        #endregion

        #region Logging

        public override int LogHeader(string executableName, string className, string itemKey = null)
        {
            int logId;
            using (var db = new SqlConnection(ConnectionString))
            {
                logId = db.ExecuteScalar<int>(@"
DECLARE @LOG_ID INT;
SELECT @LOG_ID = NEXT VALUE FOR SEQ_LOG;

INSERT INTO LOG_HEADER (
    LOG_ID,
    EXECUTABLE,
    CLASS,
    ITEM_KEY
) SELECT @LOG_ID, @EXECUTABLE, @CLASS, @ITEM_KEY;

SELECT @LOG_ID", new
                {
                    EXECUTABLE = executableName,
                    CLASS = className,
                    ITEM_KEY = itemKey
                });
            }

            return logId;
        }

        public override void Log(LogEventArgs e)
        {
            string logMethod = e.Caller.Name;
            string logClass = e.Caller.DeclaringType.Name;
            string logExecutable = e.Caller.DeclaringType.Assembly.GetName().Name;
            int? rowsAffected = null;

            // Get the LogId + Rows Affected from State. LOG_ID is mandatory.
            if (e.State == null)
            {
                throw new Exception($"Log state cannot be null.");
            }

            // Mandatory
            if (!e.State.ContainsKey("LOG_ID"))
                throw new Exception("Log state must contain LOG_ID value.");

            var logId = (int)e.State["LOG_ID"];


            if (e.State.ContainsKey("ROWS"))
                rowsAffected = (int)e.State["ROWS"];

            var message = e.Message;
            if (e.Exception != null)
                message = e.Exception.Message + Environment.NewLine + e.Exception.StackTrace;

            using (var db = new SqlConnection(ConnectionString))
            {
                db.Execute(@"
DECLARE @LOG_ITEM_ID INT;
SELECT @LOG_ITEM_ID = NEXT VALUE FOR SEQ_LOG_ITEM;

INSERT INTO LOG_ITEM (
    LOG_ITEM_ID,
    LOG_ID,
    LOG_DT,
    LOG_TYPE,
    EXECUTABLE,
    CLASS,
    METHOD,
    MESSAGE,
    ROWS_AFFECTED
) SELECT @LOG_ITEM_ID, @LOG_ID, @LOG_DT, @LOG_TYPE, @EXECUTABLE, @CLASS, @METHOD, @MESSAGE, @ROWS_AFFECTED", new
                {
                    LOG_ID = logId,
                    LOG_DT = DateTime.Now,
                    LOG_TYPE = e.LogType.ToText(),
                    EXECUTABLE = logExecutable,
                    CLASS = logClass,
                    METHOD = logMethod,
                    MESSAGE = (e.Message != null && e.Message.Length > 1000) ? e.Message.Substring(0, 1000) : e.Message,
                    ROWS_AFFECTED = rowsAffected
                });
            }
        }

        public override void LogHeaderStatus(int logId, bool? successFlag)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                logId = db.ExecuteScalar<int>(@"UPDATE LOG_HEADER SET SUCCESS_FLAG = @SUCCESS_FLAG WHERE LOG_ID = @LOG_ID", new
                {
                    LOG_ID = logId,
                    SUCCESS_FLAG = successFlag
                });
            }
        }

        public override bool GetCancelledStatus(int logId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                // Check for manual cancellation
                var cancelled = db.ExecuteScalar<Boolean>("SELECT CANCELLED_FLAG FROM LOG_HEADER WHERE LOG_ID = @LOG_ID", new
                {
                    LOG_ID = logId
                });
                return cancelled;
            }
        }

        public override IEnumerable<LogInfo> LogsGet(int daysHistory = 7, string logClass = null, string itemKey = null)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var logs = db.Query<LogInfo>("SELECT * FROM DBO.TVF_GET_LOG(@DAYS_HISTORY, @CLASS, @ITEM_KEY)", new
                {
                    DAYS_HISTORY = daysHistory,
                    CLASS = logClass,
                    ITEM_KEY = itemKey
                }).OrderBy(l => l.LogId).ToList();

                return logs;
            }
        }

        public override IEnumerable<LogItemInfo> LogItemsGet(int logId)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var logs = db.Query<LogItemInfo>("SELECT * FROM LOG_ITEM WHERE LOG_ID = @LOG_ID", new { LOG_ID = logId });
                return logs;
            }
        }

        /// <summary>
        /// Gets the last log for each configurable command id. Note that
        /// this does NOT return information for any commands run via the
        /// command class.
        /// </summary>
        /// <returns></returns>
        public override IEnumerable<ConfigurableCommandLastLogInfo> ConfigurableCommandLastLogs()
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                return db.Query<ConfigurableCommandLastLogInfo>(@"
WITH cteLastLogByItemKey
AS
(
	SELECT
		ITEM_KEY,
		MAX(LOG_ID) LOG_ID
	FROM
		TVF_GET_LOG(365, NULL, NULL)
	--WHERE
		--CLASS = ('ConfigurableCommandExecuterService')
	GROUP BY
		ITEM_KEY
)

SELECT
	CC.CONFIGURABLE_COMMAND_ID,
	LL.LOG_ID,
	LG.START_DT LAST_RUN_DT,
	LG.DURATION,
	LG.LOG_STATUS,
	LG.ROWS_AFFECTED
FROM
	TVF_GET_LOG(365, NULL, NULL) LG
INNER JOIN
	cteLastLogByItemKey LL
ON
	LG.LOG_ID = LL.LOG_ID AND
	LG.ITEM_KEY = LL.ITEM_KEY
INNER JOIN
	CONFIGURABLE_COMMAND CC
ON
	LG.ITEM_KEY = CAST(CC.CONFIGURABLE_COMMAND_ID AS VARCHAR(8))
", commandTimeout: 60 * 10);
            }
        }

        #endregion

        #region Server Cache

        public override void SaveServerObjects(IEnumerable<ServerObjectInfo> serverObjects)
        {
            using (var connection = new SqlConnection(ConnectionString))
            {
                //Logger.Log(LogType.INFORMATION, string.Format("Getting server objects for database: {0}.", database));
                connection.Open();
                var data = serverObjects.Select(s => s.ToDictionary((s) => s.ToSnakeCase().ToUpper()));
                var schema = data.ProbeColumns().ToDictionary(c => c.ColumnName, c => c.DataType.ToDotNetType());
                connection.Execute("DELETE FROM SERVER_OBJECT");
                connection.BulkCopy(data, schema, "SERVER_OBJECT");
            }
        }

        public override void SaveServerColumns(IEnumerable<ServerColumnInfo> serverColumns)
        {
            using (var connection = new SqlConnection(ConnectionString))
            {
                //Logger.Log(LogType.INFORMATION, string.Format("Getting object columns for database: {0}.", database));
                connection.Open();
                var data = serverColumns.Select(s => s.ToDictionary((s) => s.ToSnakeCase().ToUpper()));
                var schema = data.ProbeColumns().ToDictionary(c => c.ColumnName, c => c.DataType.ToDotNetType());
                connection.Execute("DELETE FROM SERVER_COLUMN");
                connection.BulkCopy(data, schema, "SERVER_COLUMN");
            }
        }

        public override void SaveServerParameters(IEnumerable<ServerParameterInfo> serverParameters)
        {
            using (var connection = new SqlConnection(ConnectionString))
            {
                //Logger.Log(LogType.INFORMATION, string.Format("Getting object columns for database: {0}.", database));
                connection.Open();
                var data = serverParameters.Select(s => s.ToDictionary((s) => s.ToSnakeCase().ToUpper()));
                var schema = data.ProbeColumns().ToDictionary(c => c.ColumnName, c => c.DataType.ToDotNetType());
                connection.Execute("DELETE FROM SERVER_PARAMETER");
                connection.BulkCopy(data, schema, "SERVER_PARAMETER");
            }
        }

        public override void SaveServerDependencies(IEnumerable<ServerDependencyInfo> serverDependencies)
        {
            using (var connection = new SqlConnection(ConnectionString))
            {
                //Logger.Log(LogType.INFORMATION, string.Format("Getting object columns for database: {0}.", database));
                connection.Open();
                var data = serverDependencies.Select(s => s.ToDictionary((s) => s.ToSnakeCase().ToUpper()));
                var schema = data.ProbeColumns().ToDictionary(c => c.ColumnName, c => c.DataType.ToDotNetType());
                connection.Execute("DELETE FROM SERVER_DEPENDENCY");
                connection.BulkCopy(data, schema, "SERVER_DEPENDENCY");
            }
        }

        #endregion

        #region Auditing

        public override int AuditBegin(string user, DateTime auditDt, string controller, string action, IDictionary<string, object> arguments)
        {
            int auditId = 0;
            var headerSql = @"
DECLARE @AUDIT_ID INT;
SELECT @AUDIT_ID = NEXT VALUE FOR SEQ_AUDIT;  
INSERT INTO AUDIT_HEADER (
    AUDIT_ID, AUDIT_DT, USER_NAME, CONTROLLER, ACTION, DURATION
)
VALUES (@AUDIT_ID, @AUDIT_DT, @USER_NAME, @CONTROLLER, @ACTION, NULL);

SELECT @AUDIT_ID;
";
            var itemSql = @"INSERT INTO AUDIT_ITEM (AUDIT_ID, ARGUMENT_NAME, ARGUMENT_VALUE) VALUES (@AUDIT_ID, @ARGUMENT_NAME, @ARGUMENT_VALUE)";

            using (var db = new SqlConnection(ConnectionString))
            {
                auditId = (int)db.ExecuteScalar(headerSql, new
                {
                    AUDIT_DT = auditDt,
                    USER_NAME = user,
                    CONTROLLER = controller,
                    ACTION = action
                });


                foreach (var argument in arguments)
                {
                    db.Execute(itemSql, new
                    {
                        AUDIT_ID = auditId,
                        ARGUMENT_NAME = argument.Key,
                        ARGUMENT_VALUE = argument.Value.ToString()
                    });
                }

                return auditId;
            }
        }

        public override void AuditEnd(int auditId, TimeSpan duration)
        {
            var sql = @"UPDATE AUDIT_HEADER SET DURATION = @DURATION WHERE AUDIT_ID = @AUDIT_ID";
            using (var db = new SqlConnection(ConnectionString))
            {
                db.Execute(sql, new
                {
                    AUDIT_ID = auditId,
                    DURATION = duration
                });
            }
        }

        #endregion

        #region Notebooks

        public override IEnumerable<NotebookInfo> GetNotebooks(string category)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var sql = "SELECT * FROM NOTEBOOK WHERE CATEGORY = @CATEGORY";
                var notebooks = db.Query<NotebookInfo>(sql, new
                {
                    CATEGORY = category
                });
                return notebooks;
            }
        }

        public override NotebookInfo GetNotebook(string category, string notebook)
        {
            var nb = GetNotebooks(category).FirstOrDefault(n => n.Notebook.Equals(notebook, StringComparison.OrdinalIgnoreCase));
            if (nb == null)
                throw new FileNotFoundException("Notebook not found.");
            else
                return nb;
        }

        public override void SaveNotebook(string category, string notebook, string script, bool overwrite = false)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                var nb = GetNotebooks(category).FirstOrDefault(n => n.Notebook.Equals(notebook, StringComparison.OrdinalIgnoreCase));

                if (nb == null)
                {
                    // new - insert
                    db.Execute("INSERT INTO NOTEBOOK (CATEGORY, NOTEBOOK, SCRIPT) SELECT @CATEGORY, @NOTEBOOK, @SCRIPT", new
                    {
                        CATEGORY = category,
                        NOTEBOOK = notebook,
                        SCRIPT = script
                    });
                }
                else
                {
                    // exists - overwrite
                    if (!overwrite)
                    {
                        throw new Exception("Cannot save as notebook already exists. To save, please set the overwrite flag before saving.");
                    }
                    // new - insert
                    db.Execute("UPDATE NOTEBOOK SET SCRIPT = @SCRIPT WHERE CATEGORY = @CATEGORY AND NOTEBOOK = @NOTEBOOK", new
                    {
                        CATEGORY = category,
                        NOTEBOOK = notebook,
                        SCRIPT = script
                    });
                }
            }
        }

        public override void DeleteNotebook(string category, string notebook)
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                db.Execute("DELETE FROM NOTEBOOK WHERE CATEGORY = @CATEGORY AND NOTEBOOK = @NOTEBOOK", new
                {
                    CATEGORY = category,
                    NOTEBOOK = notebook
                });
            }
        }

        #endregion

        #region Maintenance

        public override void Maintenance()
        {
            using (var db = new SqlConnection(ConnectionString))
            {
                // Remove invalid queue entries
                // Sometimes a queue entry does not get removed upon completion, stopping the next run occuring
                // Any queue entry > 2 hours old and marked as 'running' cannot be so, so we can safely delete.

                db.Execute("DELETE FROM CONFIGURABLE_COMMAND_QUEUE WHERE RUNNING = 1 AND NEXT_DT < DATEADD(HH, -2, GETDATE())");

                // Trim the logs

                var logRetentionDays = int.Parse(this.GetConfiguration().First(c => c.ConfigurationName.Equals("LOG_RETENTION_DAYS")).ConfigurationValue);
                var logRetentionRows = int.Parse(this.GetConfiguration().First(c => c.ConfigurationName.Equals("LOG_RETENTION_ROWS")).ConfigurationValue);

                db.Execute(@"
DECLARE @IDS TABLE (
 LOG_ID INT
)

-- GET LOG ENTRIES > x DAYS OLD
INSERT INTO @IDS SELECT DISTINCT LOG_ID FROM LOG_ITEM WHERE LOG_DT <= DATEADD(dd,-@LOG_RETENTION_DAYS, GETDATE())
-- GET LOG ENTRIES > x ROWS OLD

;WITH cte
AS
(
	SELECT LOG_ID, ROW_NUMBER() OVER (ORDER BY LOG_ID DESC) SEQ FROM LOG_HEADER
)
INSERT INTO @IDS SELECT LOG_ID FROM cte T1 WHERE SEQ > @LOG_RETENTION_ROWS AND NOT EXISTS (SELECT NULL FROM @IDS T2 WHERE T1.LOG_ID = T2.LOG_ID);

DELETE FROM LOG_ITEM WHERE EXISTS (SELECT NULL FROM @IDS T2 WHERE LOG_ITEM.LOG_ID = T2.LOG_ID)
DELETE FROM LOG_HEADER WHERE EXISTS (SELECT NULL FROM @IDS T2 WHERE LOG_HEADER.LOG_ID = T2.LOG_ID)

-- DELETE ANY LOG HEADERS WHERE THERE ARE NO ITEM RECORDS
DELETE FROM LOG_HEADER WHERE NOT EXISTS (SELECT NULL FROM LOG_ITEM LI WHERE LI.LOG_ID = LOG_HEADER.LOG_ID)", new
                {
                    LOG_RETENTION_DAYS = logRetentionDays,
                    LOG_RETENTION_ROWS = logRetentionRows
                }, null, 60 * 10);
            }
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Returns the base/real object for an object. If object is SYNONYM,
        /// gets the base object. Otherwise, returns the object.
        /// </summary>
        /// <param name="ds"></param>
        /// <returns></returns>
        private string GetBaseObject(DatasetSummaryInfo ds)
        {
            var sql = @"
SELECT
	TOP 1 CHILD_NAME
FROM
	BASE_OBJECT
WHERE
	PARENT_NAME  = @SOURCE_NAME";

            using (var db = new SqlConnection(ConnectionString))
            {
                var baseName = db.ExecuteScalar<string>(sql, new
                {
                    SOURCE_NAME = ds.SourceName
                });
                return baseName ?? ds.SourceName;
            }
        }

        private IEnumerable<ServerColumnInfo> GetColumns(DatasetSummaryInfo ds)
        {
            var name = GetBaseObject(ds);
            var sql = @"
SELECT
    SERVER_NAME,
    OBJECT_NAME,
    COLUMN_NAME,
    [ORDER],
    PRIMARY_KEY,
	DATA_TYPE,
	DATA_LENGTH,
    PRECISION,
    SCALE,
    [READ_ONLY],
    [PUBLIC]
FROM
    SERVER_COLUMN
WHERE
    OBJECT_NAME = @OBJECT_NAME
ORDER BY
    [ORDER]";
            using (var db = new SqlConnection(ConnectionString))
            {
                var columns = db.Query<ServerColumnInfo>(sql, new { OBJECT_NAME = name });
                return columns;
            }
        }

        private string[] GetTop3Users(DatasetSummaryInfo ds)
        {

            var sql = @"
WITH cte
AS
(
	SELECT
		AUD.USER_NAME,
		COUNT(1) C
	FROM
		-- SELECT * FROM 
		DATASET_AUDIT AUD
	INNER JOIN
		DATASET DS
	ON
		AUD.CATEGORY = DS.CATEGORY AND
		AUD.DATASET = DS.DATASET
	WHERE
		DS.SOURCE_NAME = @SOURCE_NAME
	GROUP BY
		AUD.USER_NAME
)
, cteRanking
AS
(
	SELECT *, RANK() OVER (ORDER BY C DESC) RANK FROM cte
)
SELECT * FROM cteRanking WHERE RANK <= 3";

            using (var db = new SqlConnection(ConnectionString))
            {
                var data = db.Query(sql, new
                {
                    SOURCE_NAME = ds.SourceName
                });
                if (data != null)
                    return data.Select(d => (string)d.USER_NAME).ToArray();
                else
                    return null;
            }
        }

        /// <summary>
        /// Returns the ranking of the dataset based on use (AUDIT).
        /// </summary>
        /// <param name="ds">Dataset.</param>
        /// <returns></returns>
        private int? GetDatasetRanking(DatasetSummaryInfo ds)
        {
            return null;
        }

        /// <summary>
        /// Gets the estimated duration for downloading this dataset.
        /// Uses historical audit entries (last 35 days).
        /// </summary>
        /// <param name="ds"></param>
        /// <returns></returns>
        private int? GetDownloadSeconds(DatasetSummaryInfo ds)
        {
            var sql = @"
SELECT
    AVG(DURATION_SECS)
FROM
    DATASET_AUDIT
WHERE
    CONTROLLER = 'DWH' AND
    ACTION = 'DATA' AND
    CATEGORY = @CATEGORY AND
    DATASET = @DATASET AND
    AUDIT_DT > DATEADD(dd, -35, GETDATE())
";
            using (var db = new SqlConnection(ConnectionString))
            {
                var o = db.ExecuteScalar<int?>(sql, new
                {
                    CATEGORY = ds.Category,
                    DATASET = ds.Dataset
                });
                return o;
            }
        }

        /// <summary>
        /// Gets parameters for a database object.
        /// Generally applies to TVF objects.
        /// </summary>
        /// <param name="ds"></param>
        /// <returns></returns>
        private IEnumerable<ServerParameterInfo> GetParameters(DatasetSummaryInfo ds)
        {
            var name = GetBaseObject(ds);
            var sql = string.Format(@"
SELECT
    SERVER_NAME,
    OBJECT_NAME,
    PARAMETER_ID,
    PARAMETER_NAME,
	DATA_TYPE,
	MAXIMUM_LENGTH,
	IS_NULLABLE
FROM
    SERVER_PARAMETER
WHERE
    OBJECT_NAME = '{0}'
ORDER BY
    PARAMETER_ID", name);
            using (var db = new SqlConnection(ConnectionString))
            {
                var parameters = db.Query<ServerParameterInfo>(sql);
                return parameters;
            }
        }

        #endregion

    }
}
