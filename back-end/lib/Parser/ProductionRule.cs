using System;
using System.Collections.Generic;
using System.Linq;


namespace Sara.Lib.Parser
{
    /// <summary>
    /// Specifies a single rule in the grammar..
    /// </summary>
    public class ProductionRule : ILoggable
    {
        public ProductionRule(string name, params string[] symbols)
        {
            this.Name = name;
            this.Symbols = new List<Symbol>();
            symbols.ToList().ForEach(s =>
            {
                var symbol = new Symbol(s, this.RuleType);
                this.Symbols.Add(symbol);
            });
        }

        public ProductionRule(string name, params Symbol[] symbols)
        {
            this.Name = name;
            this.Symbols = new List<Symbol>();
            foreach (var symbol in symbols)
            {
                this.Symbols.Add(symbol);
            }
        }

        /// <summary>
        /// Name of the rule. Used to name nodes of the abstract syntax tree.
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Returns true for production rules that have been generated by the
        /// parser instead of explicitly defined by the caller.
        /// </summary>
        public bool IsGenerated => this.Name.Contains("'");

        /// <summary>
        /// Returns the original / explicit production rule.
        /// </summary>
        public string OriginalProductionRule => this.Name.Replace("'", "");

        /// <summary>
        /// Rule Type. If the first character of the rule is upper case, it is defined
        /// as a lexer rule. Otherwise, it is a parser rule.
        /// </summary>
        public RuleType RuleType
        {
            get
            {
                if (char.IsUpper(this.Name[0]))
                    return RuleType.LexerRule;
                else
                    return RuleType.ParserRule;
            }
        }

        /// <summary>
        /// The symbols that make up this rule.
        /// </summary>
        public List<Symbol> Symbols { get; set; }

        public Action<object, LogArgs> LogHandler { get; set; }

        /// <summary>
        /// Returns true if a symbol exists more than once, or the symbol is of type 'many'.
        /// Such symbols use an IEnumerable in the tree to represent the members.
        /// </summary>
        /// <param name="alias">The alias used in the production rule.</param>
        /// <returns></returns>
        public bool IsEnumeratedSymbol(string alias)
        {
            var isList = false;
            var found = false;

            var symbols = Symbols.Where(s => s.Alias == alias);

            if (symbols.Count() >= 1)
            {
                found = true;
                if (symbols.Count() > 1)
                    isList = true;
                else
                {
                    var symbol = symbols.First();
                    if (symbol.Many)
                        isList = true;
                }
            }

            if (!found)
            {
                throw new Exception($"Symbol {alias} does not exist in production rule {this.Name}.");
            }

            return isList;
        }

        /// <summary>
        /// Parses a set of tokens into an abstract syntax tree.
        /// </summary>
        /// <param name="context">The parser context.</param>
        /// <returns>The return object contains a portion of the tree (object / node) parsed by this production rule alone.</returns>
        public bool Parse(ParserContext context, out object obj)
        {
            LogHandler?.Invoke(this, new LogArgs
            {
                LogType = LogType.BEGIN,
                NestingLevel = context.CurrentProductionRule.Count(),
                Message = $"{this.Name} - Pushing new result to stack."
            });

            context.CurrentProductionRule.Push(this);
            context.PushResult(GetResultObject());

            var temp = context.CurrentTokenIndex;
            bool success = true;

            // Rule is non terminal
            foreach (var symbol in this.Symbols)
            {
                symbol.LogHandler = this.LogHandler;
                if (symbol.Optional && context.TokenEOF)
                    continue;

                var ok = symbol.Parse(context);

                if (symbol.Optional || ok) { }
                else
                {
                    // General case if ok = false
                    success = false;
                    break;
                }
            }

            obj = context.PopResult();
            context.CurrentProductionRule.Pop();

            if (success)
            {
                LogHandler?.Invoke(this, new LogArgs
                {
                    LogType = LogType.SUCCESS,
                    NestingLevel = context.CurrentProductionRule.Count()
                });

                return true;
            }
            else
            {
                LogHandler?.Invoke(this, new LogArgs
                {
                    LogType = LogType.FAILURE,
                    NestingLevel = context.CurrentProductionRule.Count()
                });

                context.CurrentTokenIndex = temp;
                obj = null;
                return false;
            }
        }

        /// <summary>
        /// Goes through all symbols in production rule, creating the appropriate
        /// result object:
        /// 1. if all symbols have aliases, create a node object
        /// 1.1 If any symbols are in a list, create IEnumerable property
        /// 2. if all symbols have no aliases, and single, create Object
        /// 2.1 if all symbols have no aliass, and multiple, create IEnumerable of Object.
        /// </summary>
        /// <param name="context"></param>
        private object GetResultObject()
        {
            bool hasBlankAlias = false;
            bool hasNonBlankAlias = false;
            object ret = null;

            // Get all the aliases
            foreach (var alias in this.Symbols.Select(s => s.Alias).Distinct())
            {
                if (!string.IsNullOrEmpty(alias))
                {
                    hasNonBlankAlias = true;

                    if (ret == null)
                        ret = new Node(this.Name);
                }
                else
                {
                    hasNonBlankAlias = false;
                    if (IsEnumeratedSymbol(alias))
                    {
                        ret = new List<object>();
                    }
                }
            }
            if (hasNonBlankAlias && hasBlankAlias)
                throw new Exception("Cannot mix blank and non-blank aliases.");

            return ret;
        }

        public override string ToString()
        {
            var symbols = string.Join(", ", this.Symbols);
            return $"{this.Name} = {symbols};";
        }
    }
}